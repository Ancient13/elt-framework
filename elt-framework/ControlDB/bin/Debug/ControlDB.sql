/*
Deployment script for ControlDB

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "ControlDB"
:setvar DefaultFilePrefix "ControlDB"
:setvar DefaultDataPath "C:\Users\bennyaustin\AppData\Local\Microsoft\VisualStudio\SSDT\ControlDB"
:setvar DefaultLogPath "C:\Users\bennyaustin\AppData\Local\Microsoft\VisualStudio\SSDT\ControlDB"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ARITHABORT ON,
                CONCAT_NULL_YIELDS_NULL ON,
                CURSOR_DEFAULT LOCAL 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET PAGE_VERIFY NONE,
                DISABLE_BROKER 
            WITH ROLLBACK IMMEDIATE;
    END


GO
ALTER DATABASE [$(DatabaseName)]
    SET TARGET_RECOVERY_TIME = 0 SECONDS 
    WITH ROLLBACK IMMEDIATE;


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET QUERY_STORE (CLEANUP_POLICY = (STALE_QUERY_THRESHOLD_DAYS = 367)) 
            WITH ROLLBACK IMMEDIATE;
    END


GO
PRINT N'Creating Schema [ELT]...';


GO
CREATE SCHEMA [ELT]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Table [ELT].[L2TransformInstance]...';


GO
CREATE TABLE [ELT].[L2TransformInstance] (
    [L2TransformInstanceID]        INT              IDENTITY (1, 1) NOT NULL,
    [L2TransformID]                INT              NULL,
    [IngestID]                     INT              NULL,
    [L1TransformID]                INT              NULL,
    [NotebookPath]                 VARCHAR (200)    NULL,
    [NotebookName]                 VARCHAR (100)    NULL,
    [CustomParameters]             VARCHAR (MAX)    NULL,
    [InputFileSystem]              VARCHAR (50)     NULL,
    [InputFileFolder]              VARCHAR (200)    NULL,
    [InputFile]                    VARCHAR (200)    NULL,
    [InputFileDelimiter]           CHAR (1)         NULL,
    [InputFileHeaderFlag]          BIT              NULL,
    [InputDWTable]                 VARCHAR (200)    NULL,
    [DeltaName]                    VARCHAR (50)     NULL,
    [DataFromTimestamp]            DATETIME2 (7)    NULL,
    [DataToTimestamp]              DATETIME2 (7)    NULL,
    [DataFromNumber]               INT              NULL,
    [DataToNumber]                 INT              NULL,
    [OutputL2CurateFileSystem]     VARCHAR (50)     NOT NULL,
    [OutputL2CuratedFolder]        VARCHAR (200)    NOT NULL,
    [OutputL2CuratedFile]          VARCHAR (200)    NOT NULL,
    [OutputL2CuratedFileDelimiter] CHAR (1)         NULL,
    [OutputL2CuratedFileFormat]    VARCHAR (10)     NULL,
    [OutputL2CuratedFileWriteMode] VARCHAR (20)     NULL,
    [OutputDWStagingTable]         VARCHAR (200)    NULL,
    [LookupColumns]                VARCHAR (4000)   NULL,
    [OutputDWTable]                VARCHAR (200)    NULL,
    [OutputDWTableWriteMode]       VARCHAR (20)     NULL,
    [InputCount]                   INT              NULL,
    [L2TransformCount]             INT              NULL,
    [L2TransformStartTimestamp]    DATETIME         NULL,
    [L2TransformEndTimestamp]      DATETIME         NULL,
    [L2TransformStatus]            VARCHAR (20)     NULL,
    [RetryCount]                   INT              NULL,
    [ActiveFlag]                   BIT              NOT NULL,
    [ReRunL2TransformFlag]         BIT              NULL,
    [IngestADFPipelineRunID]       UNIQUEIDENTIFIER NULL,
    [L1TransformADFPipelineRunID]  UNIQUEIDENTIFIER NULL,
    [L2TransformADFPipelineRunID]  UNIQUEIDENTIFIER NULL,
    [CreatedBy]                    VARCHAR (50)     NOT NULL,
    [CreatedTimestamp]             DATETIME         NOT NULL,
    [ModifiedBy]                   VARCHAR (50)     NULL,
    [ModifiedTimestamp]            DATETIME         NULL,
    [L2SnapshotGroupID]            INT              NULL,
    [L2SnapshotInstanceID]         INT              NULL,
    CONSTRAINT [PK_L2TransformInstance] PRIMARY KEY CLUSTERED ([L2TransformInstanceID] ASC)
);


GO
PRINT N'Creating Index [ELT].[L2TransformInstance].[UI_L2TransformInstance]...';


GO
CREATE NONCLUSTERED INDEX [UI_L2TransformInstance]
    ON [ELT].[L2TransformInstance]([InputFileSystem] ASC, [InputFileFolder] ASC, [InputFile] ASC, [InputDWTable] ASC, [OutputL2CurateFileSystem] ASC, [OutputL2CuratedFolder] ASC, [OutputL2CuratedFile] ASC);


GO
PRINT N'Creating Table [ELT].[L2TransformDefinition]...';


GO
CREATE TABLE [ELT].[L2TransformDefinition] (
    [L2TransformID]                INT            IDENTITY (1, 1) NOT NULL,
    [IngestID]                     INT            NULL,
    [L1TransformID]                INT            NULL,
    [NotebookPath]                 VARCHAR (200)  NULL,
    [NotebookName]                 VARCHAR (100)  NULL,
    [CustomParameters]             VARCHAR (MAX)  NULL,
    [InputType]                    VARCHAR (15)   NULL,
    [InputFileSystem]              VARCHAR (50)   NULL,
    [InputFileFolder]              VARCHAR (200)  NULL,
    [InputFile]                    VARCHAR (200)  NULL,
    [InputFileDelimiter]           CHAR (1)       NULL,
    [InputFileHeaderFlag]          BIT            NULL,
    [InputDWTable]                 VARCHAR (200)  NULL,
    [DeltaName]                    VARCHAR (50)   NULL,
    [LastDeltaDate]                DATETIME2 (7)  NULL,
    [LastDeltaNumber]              INT            NULL,
    [MaxIntervalMinutes]           INT            NULL,
    [MaxIntervalNumber]            INT            NULL,
    [MaxRetries]                   INT            NULL,
    [OutputL2CurateFileSystem]     VARCHAR (50)   NULL,
    [OutputL2CuratedFolder]        VARCHAR (200)  NULL,
    [OutputL2CuratedFile]          VARCHAR (200)  NULL,
    [OutputL2CuratedFileDelimiter] CHAR (1)       NULL,
    [OutputL2CuratedFileFormat]    VARCHAR (10)   NULL,
    [OutputL2CuratedFileWriteMode] VARCHAR (20)   NULL,
    [OutputDWStagingTable]         VARCHAR (200)  NULL,
    [LookupColumns]                VARCHAR (4000) NULL,
    [OutputDWTable]                VARCHAR (200)  NULL,
    [OutputDWTableWriteMode]       VARCHAR (20)   NULL,
    [ActiveFlag]                   BIT            NOT NULL,
    [RunSequence]                  INT            NOT NULL,
    [CreatedBy]                    VARCHAR (50)   NOT NULL,
    [CreatedTimestamp]             DATETIME       NOT NULL,
    [ModifiedBy]                   VARCHAR (50)   NULL,
    [ModifiedTimestamp]            DATETIME       NULL,
    CONSTRAINT [PK_L2TransformDefinition] PRIMARY KEY CLUSTERED ([L2TransformID] ASC)
);


GO
PRINT N'Creating Index [ELT].[L2TransformDefinition].[UI_L2TransformDefinition]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UI_L2TransformDefinition]
    ON [ELT].[L2TransformDefinition]([InputFileSystem] ASC, [InputFileFolder] ASC, [InputFile] ASC, [InputDWTable] ASC, [OutputL2CurateFileSystem] ASC, [OutputL2CuratedFolder] ASC, [OutputL2CuratedFile] ASC);


GO
PRINT N'Creating Table [ELT].[L1TransformInstance]...';


GO
CREATE TABLE [ELT].[L1TransformInstance] (
    [L1TransformInstanceID]        INT              IDENTITY (1, 1) NOT NULL,
    [L1TransformID]                INT              NOT NULL,
    [IngestInstanceID]             INT              NULL,
    [IngestID]                     INT              NOT NULL,
    [NotebookName]                 VARCHAR (100)    NULL,
    [NotebookPath]                 VARCHAR (200)    NULL,
    [CustomParameters]             VARCHAR (MAX)    NULL,
    [InputRawFileSystem]           VARCHAR (50)     NOT NULL,
    [InputRawFileFolder]           VARCHAR (200)    NOT NULL,
    [InputRawFile]                 VARCHAR (200)    NOT NULL,
    [InputRawFileDelimiter]        CHAR (1)         NULL,
    [InputFileHeaderFlag]          BIT              NULL,
    [OutputL1CurateFileSystem]     VARCHAR (50)     NOT NULL,
    [OutputL1CuratedFolder]        VARCHAR (200)    NOT NULL,
    [OutputL1CuratedFile]          VARCHAR (200)    NOT NULL,
    [OutputL1CuratedFileDelimiter] CHAR (1)         NULL,
    [OutputL1CuratedFileFormat]    VARCHAR (10)     NULL,
    [OutputL1CuratedFileWriteMode] VARCHAR (20)     NULL,
    [OutputDWStagingTable]         VARCHAR (200)    NULL,
    [LookupColumns]                VARCHAR (4000)   NULL,
    [OutputDWTable]                VARCHAR (200)    NULL,
    [OutputDWTableWriteMode]       VARCHAR (20)     NULL,
    [IngestCount]                  INT              NULL,
    [L1TransformCount]             INT              NULL,
    [L1TransformStartTimestamp]    DATETIME         NULL,
    [L1TransformEndTimestamp]      DATETIME         NULL,
    [L1TransformStatus]            VARCHAR (20)     NULL,
    [RetryCount]                   INT              NULL,
    [ActiveFlag]                   BIT              NOT NULL,
    [ReRunL1TransformFlag]         BIT              NULL,
    [IngestADFPipelineRunID]       UNIQUEIDENTIFIER NULL,
    [L1TransformADFPipelineRunID]  UNIQUEIDENTIFIER NULL,
    [CreatedBy]                    VARCHAR (50)     NOT NULL,
    [CreatedTimestamp]             DATETIME         NOT NULL,
    [ModifiedBy]                   VARCHAR (50)     NULL,
    [ModifiedTimestamp]            DATETIME         NULL,
    CONSTRAINT [PK_L1TransformInstance] PRIMARY KEY CLUSTERED ([L1TransformInstanceID] ASC)
);


GO
PRINT N'Creating Index [ELT].[L1TransformInstance].[UI_L1TransformInstance]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UI_L1TransformInstance]
    ON [ELT].[L1TransformInstance]([InputRawFileSystem] ASC, [InputRawFileFolder] ASC, [InputRawFile] ASC, [OutputL1CurateFileSystem] ASC, [OutputL1CuratedFolder] ASC, [OutputL1CuratedFile] ASC);


GO
PRINT N'Creating Table [ELT].[L1TransformDefinition]...';


GO
CREATE TABLE [ELT].[L1TransformDefinition] (
    [L1TransformID]                INT            IDENTITY (1, 1) NOT NULL,
    [IngestID]                     INT            NOT NULL,
    [NotebookPath]                 VARCHAR (200)  NULL,
    [NotebookName]                 VARCHAR (100)  NULL,
    [CustomParameters]             VARCHAR (MAX)  NULL,
    [InputRawFileSystem]           VARCHAR (50)   NOT NULL,
    [InputRawFileFolder]           VARCHAR (200)  NOT NULL,
    [InputRawFile]                 VARCHAR (200)  NOT NULL,
    [InputRawFileDelimiter]        CHAR (1)       NULL,
    [InputFileHeaderFlag]          BIT            NULL,
    [OutputL1CurateFileSystem]     VARCHAR (50)   NOT NULL,
    [OutputL1CuratedFolder]        VARCHAR (200)  NOT NULL,
    [OutputL1CuratedFile]          VARCHAR (200)  NOT NULL,
    [OutputL1CuratedFileDelimiter] CHAR (1)       NULL,
    [OutputL1CuratedFileFormat]    VARCHAR (10)   NULL,
    [OutputL1CuratedFileWriteMode] VARCHAR (20)   NULL,
    [OutputDWStagingTable]         VARCHAR (200)  NULL,
    [LookupColumns]                VARCHAR (4000) NULL,
    [OutputDWTable]                VARCHAR (200)  NULL,
    [OutputDWTableWriteMode]       VARCHAR (20)   NULL,
    [MaxRetries]                   INT            NULL,
    [DeltaName]                    VARCHAR (50)   NULL,
    [ActiveFlag]                   BIT            NOT NULL,
    [CreatedBy]                    VARCHAR (50)   NOT NULL,
    [CreatedTimestamp]             DATETIME       NOT NULL,
    [ModifiedBy]                   VARCHAR (50)   NULL,
    [ModifiedTimestamp]            DATETIME       NULL,
    CONSTRAINT [PK_L1TransformDefinition] PRIMARY KEY CLUSTERED ([L1TransformID] ASC)
);


GO
PRINT N'Creating Index [ELT].[L1TransformDefinition].[UI_L1TransformDefinition]...';


GO
CREATE NONCLUSTERED INDEX [UI_L1TransformDefinition]
    ON [ELT].[L1TransformDefinition]([InputRawFileSystem] ASC, [InputRawFileFolder] ASC, [InputRawFile] ASC, [OutputL1CurateFileSystem] ASC, [OutputL1CuratedFolder] ASC, [OutputL1CuratedFile] ASC);


GO
PRINT N'Creating Table [ELT].[IngestInstance]...';


GO
CREATE TABLE [ELT].[IngestInstance] (
    [IngestInstanceID]         INT              IDENTITY (1, 1) NOT NULL,
    [IngestID]                 INT              NOT NULL,
    [SourceFileDropFileSystem] VARCHAR (50)     NULL,
    [SourceFileDropFolder]     VARCHAR (200)    NULL,
    [SourceFileDropFile]       VARCHAR (200)    NULL,
    [DestinationRawFileSystem] VARCHAR (50)     NOT NULL,
    [DestinationRawFolder]     VARCHAR (200)    NOT NULL,
    [DestinationRawFile]       VARCHAR (200)    NOT NULL,
    [DataFromTimestamp]        DATETIME2 (7)    NULL,
    [DataToTimestamp]          DATETIME2 (7)    NULL,
    [DataFromNumber]           INT              NULL,
    [DataToNumber]             INT              NULL,
    [SourceCount]              INT              NULL,
    [IngestCount]              INT              NULL,
    [IngestStartTimestamp]     DATETIME         NULL,
    [IngestEndTimestamp]       DATETIME         NULL,
    [IngestStatus]             VARCHAR (20)     NULL,
    [RetryCount]               INT              NULL,
    [ReloadFlag]               BIT              NULL,
    [CreatedBy]                VARCHAR (50)     NOT NULL,
    [CreatedTimestamp]         DATETIME         NOT NULL,
    [ModifiedBy]               VARCHAR (50)     NULL,
    [ModifiedTimestamp]        DATETIME         NULL,
    [ADFIngestPipelineRunID]   UNIQUEIDENTIFIER NULL,
    CONSTRAINT [PK_IngestInstance] PRIMARY KEY CLUSTERED ([IngestInstanceID] ASC)
);


GO
PRINT N'Creating Index [ELT].[IngestInstance].[UI_IngestInstance]...';


GO
CREATE NONCLUSTERED INDEX [UI_IngestInstance]
    ON [ELT].[IngestInstance]([DestinationRawFileSystem] ASC, [DestinationRawFolder] ASC, [DestinationRawFile] ASC);


GO
PRINT N'Creating Table [ELT].[IngestDefinition]...';


GO
CREATE TABLE [ELT].[IngestDefinition] (
    [IngestID]                  INT           IDENTITY (1, 1) NOT NULL,
    [SourceSystemName]          VARCHAR (50)  NOT NULL,
    [StreamName]                VARCHAR (100) NULL,
    [SourceSystemDescription]   VARCHAR (200) NULL,
    [Backend]                   VARCHAR (30)  NULL,
    [DataFormat]                VARCHAR (10)  NULL,
    [EntityName]                VARCHAR (100) NULL,
    [DeltaName]                 VARCHAR (50)  NULL,
    [DeltaFormat]               VARCHAR (30)  NULL,
    [LastDeltaDate]             DATETIME2 (7) NULL,
    [LastDeltaNumber]           INT           NULL,
    [LastDeltaString]           VARCHAR (50)  NULL,
    [MaxIntervalMinutes]        INT           NULL,
    [MaxIntervalNumber]         INT           NULL,
    [DataMapping]               VARCHAR (MAX) NULL,
    [SourceFileDropFileSystem]  VARCHAR (50)  NULL,
    [SourceFileDropFolder]      VARCHAR (200) NULL,
    [SourceFileDropFile]        VARCHAR (200) NULL,
    [SourceFileDelimiter]       CHAR (1)      NULL,
    [SourceFileHeaderFlag]      BIT           NULL,
    [SourceStructure]           VARCHAR (MAX) NULL,
    [DestinationRawFileSystem]  VARCHAR (50)  NULL,
    [DestinationRawFolder]      VARCHAR (200) NULL,
    [DestinationRawFile]        VARCHAR (200) NULL,
    [RunSequence]               INT           NULL,
    [MaxRetries]                INT           NULL,
    [ActiveFlag]                BIT           NOT NULL,
    [L1TransformationReqdFlag]  BIT           NOT NULL,
    [L2TransformationReqdFlag]  BIT           NOT NULL,
    [DelayL1TransformationFlag] BIT           NOT NULL,
    [DelayL2TransformationFlag] BIT           NOT NULL,
    [CreatedBy]                 VARCHAR (50)  NOT NULL,
    [CreatedTimestamp]          DATETIME      NOT NULL,
    [ModifiedBy]                VARCHAR (50)  NULL,
    [ModifiedTimestamp]         DATETIME      NULL,
    CONSTRAINT [PK_IngestDefinition] PRIMARY KEY CLUSTERED ([IngestID] ASC)
);


GO
PRINT N'Creating Index [ELT].[IngestDefinition].[UI_IngestDefinition]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UI_IngestDefinition]
    ON [ELT].[IngestDefinition]([SourceSystemName] ASC, [StreamName] ASC);


GO
PRINT N'Creating Default Constraint [ELT].[DC_L2TransformDefinition_MaxRetries]...';


GO
ALTER TABLE [ELT].[L2TransformDefinition]
    ADD CONSTRAINT [DC_L2TransformDefinition_MaxRetries] DEFAULT 3 FOR [MaxRetries];


GO
PRINT N'Creating Default Constraint [ELT].[DC_L2TransformDefinition_CreatedTimestamp]...';


GO
ALTER TABLE [ELT].[L2TransformDefinition]
    ADD CONSTRAINT [DC_L2TransformDefinition_CreatedTimestamp] DEFAULT CONVERT(datetime,CONVERT(datetimeoffset, getdate()) at time zone 'AUS Eastern Standard Time') FOR [CreatedTimestamp];


GO
PRINT N'Creating Default Constraint [ELT].[DC_L2TransformDefinition_CreatedBy]...';


GO
ALTER TABLE [ELT].[L2TransformDefinition]
    ADD CONSTRAINT [DC_L2TransformDefinition_CreatedBy] DEFAULT suser_sname() FOR [CreatedBy];


GO
PRINT N'Creating Default Constraint [ELT].[DC_L2TransformDefinition_RunSequence]...';


GO
ALTER TABLE [ELT].[L2TransformDefinition]
    ADD CONSTRAINT [DC_L2TransformDefinition_RunSequence] DEFAULT 100 FOR [RunSequence];


GO
PRINT N'Creating Default Constraint [ELT].[DC_L2TransformDefinition_ModifiedTimestamp]...';


GO
ALTER TABLE [ELT].[L2TransformDefinition]
    ADD CONSTRAINT [DC_L2TransformDefinition_ModifiedTimestamp] DEFAULT CONVERT(datetime,CONVERT(datetimeoffset, getdate()) at time zone 'AUS Eastern Standard Time') FOR [ModifiedTimestamp];


GO
PRINT N'Creating Default Constraint [ELT].[DC_L2TransformDefinition_ModifiedBy]...';


GO
ALTER TABLE [ELT].[L2TransformDefinition]
    ADD CONSTRAINT [DC_L2TransformDefinition_ModifiedBy] DEFAULT suser_sname() FOR [ModifiedBy];


GO
PRINT N'Creating Default Constraint [ELT].[DC_L1TransformDefinition_ModifiedTimestamp]...';


GO
ALTER TABLE [ELT].[L1TransformDefinition]
    ADD CONSTRAINT [DC_L1TransformDefinition_ModifiedTimestamp] DEFAULT CONVERT(datetime,CONVERT(datetimeoffset, getdate()) at time zone 'AUS Eastern Standard Time') FOR [ModifiedTimestamp];


GO
PRINT N'Creating Default Constraint [ELT].[DC_L1TransformDefinition_ModifiedBy]...';


GO
ALTER TABLE [ELT].[L1TransformDefinition]
    ADD CONSTRAINT [DC_L1TransformDefinition_ModifiedBy] DEFAULT suser_sname() FOR [ModifiedBy];


GO
PRINT N'Creating Default Constraint [ELT].[DC_L1TransformDefinition_MaxRetries]...';


GO
ALTER TABLE [ELT].[L1TransformDefinition]
    ADD CONSTRAINT [DC_L1TransformDefinition_MaxRetries] DEFAULT 3 FOR [MaxRetries];


GO
PRINT N'Creating Default Constraint [ELT].[DC_L1TransformDefinition_CreatedTimestamp]...';


GO
ALTER TABLE [ELT].[L1TransformDefinition]
    ADD CONSTRAINT [DC_L1TransformDefinition_CreatedTimestamp] DEFAULT CONVERT(datetime,CONVERT(datetimeoffset, getdate()) at time zone 'AUS Eastern Standard Time') FOR [CreatedTimestamp];


GO
PRINT N'Creating Default Constraint [ELT].[DC_L1TransformDefinition_CreatedBy]...';


GO
ALTER TABLE [ELT].[L1TransformDefinition]
    ADD CONSTRAINT [DC_L1TransformDefinition_CreatedBy] DEFAULT suser_sname() FOR [CreatedBy];


GO
PRINT N'Creating Default Constraint [ELT].[DC_IngestDefinition_RunSequence]...';


GO
ALTER TABLE [ELT].[IngestDefinition]
    ADD CONSTRAINT [DC_IngestDefinition_RunSequence] DEFAULT 100 FOR [RunSequence];


GO
PRINT N'Creating Default Constraint [ELT].[DC_IngestDefinition_ModifiedTimestamp]...';


GO
ALTER TABLE [ELT].[IngestDefinition]
    ADD CONSTRAINT [DC_IngestDefinition_ModifiedTimestamp] DEFAULT CONVERT(datetime,CONVERT(datetimeoffset, getdate()) at time zone 'AUS Eastern Standard Time') FOR [ModifiedTimestamp];


GO
PRINT N'Creating Default Constraint [ELT].[DC_IngestDefinition_ModifiedBy]...';


GO
ALTER TABLE [ELT].[IngestDefinition]
    ADD CONSTRAINT [DC_IngestDefinition_ModifiedBy] DEFAULT suser_sname() FOR [ModifiedBy];


GO
PRINT N'Creating Default Constraint [ELT].[DC_IngestDefinition_MaxRetries]...';


GO
ALTER TABLE [ELT].[IngestDefinition]
    ADD CONSTRAINT [DC_IngestDefinition_MaxRetries] DEFAULT 3 FOR [MaxRetries];


GO
PRINT N'Creating Default Constraint [ELT].[DC_IngestDefinition_DelayL2TransformationFlag]...';


GO
ALTER TABLE [ELT].[IngestDefinition]
    ADD CONSTRAINT [DC_IngestDefinition_DelayL2TransformationFlag] DEFAULT 1 FOR [DelayL2TransformationFlag];


GO
PRINT N'Creating Default Constraint [ELT].[DC_IngestDefinition_DelayL1TransformationFlag]...';


GO
ALTER TABLE [ELT].[IngestDefinition]
    ADD CONSTRAINT [DC_IngestDefinition_DelayL1TransformationFlag] DEFAULT 1 FOR [DelayL1TransformationFlag];


GO
PRINT N'Creating Default Constraint [ELT].[DC_IngestDefinition_CreatedTimestamp]...';


GO
ALTER TABLE [ELT].[IngestDefinition]
    ADD CONSTRAINT [DC_IngestDefinition_CreatedTimestamp] DEFAULT CONVERT(datetime,CONVERT(datetimeoffset, getdate()) at time zone 'AUS Eastern Standard Time') FOR [CreatedTimestamp];


GO
PRINT N'Creating Default Constraint [ELT].[DC_IngestDefinition_CreatedBy]...';


GO
ALTER TABLE [ELT].[IngestDefinition]
    ADD CONSTRAINT [DC_IngestDefinition_CreatedBy] DEFAULT suser_sname() FOR [CreatedBy];


GO
PRINT N'Creating Foreign Key [ELT].[FK_L2TransformInstance_L2TransformID]...';


GO
ALTER TABLE [ELT].[L2TransformInstance] WITH NOCHECK
    ADD CONSTRAINT [FK_L2TransformInstance_L2TransformID] FOREIGN KEY ([L2TransformID]) REFERENCES [ELT].[L2TransformDefinition] ([L2TransformID]);


GO
PRINT N'Creating Foreign Key [ELT].[FK_L2TransformInstance_L1TransformID]...';


GO
ALTER TABLE [ELT].[L2TransformInstance] WITH NOCHECK
    ADD CONSTRAINT [FK_L2TransformInstance_L1TransformID] FOREIGN KEY ([L1TransformID]) REFERENCES [ELT].[L1TransformDefinition] ([L1TransformID]);


GO
PRINT N'Creating Foreign Key [ELT].[FK_L2TransformInstance_IngestID]...';


GO
ALTER TABLE [ELT].[L2TransformInstance] WITH NOCHECK
    ADD CONSTRAINT [FK_L2TransformInstance_IngestID] FOREIGN KEY ([IngestID]) REFERENCES [ELT].[IngestDefinition] ([IngestID]);


GO
PRINT N'Creating Foreign Key [ELT].[FK_L2TransformDefinition_IngestID]...';


GO
ALTER TABLE [ELT].[L2TransformDefinition] WITH NOCHECK
    ADD CONSTRAINT [FK_L2TransformDefinition_IngestID] FOREIGN KEY ([IngestID]) REFERENCES [ELT].[IngestDefinition] ([IngestID]);


GO
PRINT N'Creating Foreign Key [ELT].[FK_L1TransformInstance_L1TransformID]...';


GO
ALTER TABLE [ELT].[L1TransformInstance] WITH NOCHECK
    ADD CONSTRAINT [FK_L1TransformInstance_L1TransformID] FOREIGN KEY ([L1TransformID]) REFERENCES [ELT].[L1TransformDefinition] ([L1TransformID]);


GO
PRINT N'Creating Foreign Key [ELT].[FK_L1TransformInstance_IngestID]...';


GO
ALTER TABLE [ELT].[L1TransformInstance] WITH NOCHECK
    ADD CONSTRAINT [FK_L1TransformInstance_IngestID] FOREIGN KEY ([IngestID]) REFERENCES [ELT].[IngestDefinition] ([IngestID]);


GO
PRINT N'Creating Foreign Key [ELT].[FK_L1TransformDefinition_IngestID]...';


GO
ALTER TABLE [ELT].[L1TransformDefinition] WITH NOCHECK
    ADD CONSTRAINT [FK_L1TransformDefinition_IngestID] FOREIGN KEY ([IngestID]) REFERENCES [ELT].[IngestDefinition] ([IngestID]);


GO
PRINT N'Creating Foreign Key [ELT].[FK_IngestInstance_IngestID]...';


GO
ALTER TABLE [ELT].[IngestInstance] WITH NOCHECK
    ADD CONSTRAINT [FK_IngestInstance_IngestID] FOREIGN KEY ([IngestID]) REFERENCES [ELT].[IngestDefinition] ([IngestID]);


GO
PRINT N'Creating Check Constraint [ELT].[CC_L2TransformInstance_OutputL2CuratedFileWriteMode]...';


GO
ALTER TABLE [ELT].[L2TransformInstance] WITH NOCHECK
    ADD CONSTRAINT [CC_L2TransformInstance_OutputL2CuratedFileWriteMode] CHECK ([OutputL2CuratedFileWriteMode]='append' OR [OutputL2CuratedFileWriteMode]= 'overwrite' OR [OutputL2CuratedFileWriteMode]= 'ignore' OR [OutputL2CuratedFileWriteMode]= 'error' OR [OutputL2CuratedFileWriteMode]= 'errorifexists');


GO
PRINT N'Creating Check Constraint [ELT].[CC_L2TransformInstance_OutputDWTableWriteMode]...';


GO
ALTER TABLE [ELT].[L2TransformInstance] WITH NOCHECK
    ADD CONSTRAINT [CC_L2TransformInstance_OutputDWTableWriteMode] CHECK ([OutputDWTableWriteMode]='append' OR [OutputDWTableWriteMode]= 'overwrite' OR [OutputDWTableWriteMode]= 'ignore' OR [OutputDWTableWriteMode]= 'error' OR [OutputDWTableWriteMode]= 'errorifexists');


GO
PRINT N'Creating Check Constraint [ELT].[CC_L2TransformInstance_L2TransformStatus]...';


GO
ALTER TABLE [ELT].[L2TransformInstance] WITH NOCHECK
    ADD CONSTRAINT [CC_L2TransformInstance_L2TransformStatus] CHECK ([L2TransformStatus] ='ReRunFailure' OR [L2TransformStatus] ='ReRunSuccess' OR [L2TransformStatus] ='Running' OR [L2TransformStatus] ='DWUpload' OR [L2TransformStatus]='Failure' OR [L2TransformStatus]='Success');


GO
PRINT N'Creating Check Constraint [ELT].[CC_L2TransformDefinition_MaxIntervalNumber]...';


GO
ALTER TABLE [ELT].[L2TransformDefinition] WITH NOCHECK
    ADD CONSTRAINT [CC_L2TransformDefinition_MaxIntervalNumber] CHECK ([MaxIntervalNumber] IS NULL OR  [MaxIntervalNumber] > 0);


GO
PRINT N'Creating Check Constraint [ELT].[CC_L2TransformDefinition_MaxIntervalMinutes]...';


GO
ALTER TABLE [ELT].[L2TransformDefinition] WITH NOCHECK
    ADD CONSTRAINT [CC_L2TransformDefinition_MaxIntervalMinutes] CHECK ([MaxIntervalMinutes] IS NULL OR  [MaxIntervalMinutes] > 0);


GO
PRINT N'Creating Check Constraint [ELT].[CC_L2TransformDefinition_InputType]...';


GO
ALTER TABLE [ELT].[L2TransformDefinition] WITH NOCHECK
    ADD CONSTRAINT [CC_L2TransformDefinition_InputType] CHECK ([InputType] ='Raw' OR [InputType] ='Curated' OR [InputType] ='Datawarehouse');


GO
PRINT N'Creating Check Constraint [ELT].[CC_L2TransformDefinition_CustomParameters]...';


GO
ALTER TABLE [ELT].[L2TransformDefinition] WITH NOCHECK
    ADD CONSTRAINT [CC_L2TransformDefinition_CustomParameters] CHECK (ISJSON([CustomParameters]) = 1);


GO
PRINT N'Creating Check Constraint [ELT].[CC_L2TransformDefinition_OutputL2CuratedFileWriteMode]...';


GO
ALTER TABLE [ELT].[L2TransformDefinition] WITH NOCHECK
    ADD CONSTRAINT [CC_L2TransformDefinition_OutputL2CuratedFileWriteMode] CHECK ([OutputL2CuratedFileWriteMode]='append' OR [OutputL2CuratedFileWriteMode]='overwrite' OR [OutputL2CuratedFileWriteMode]='ignore' OR [OutputL2CuratedFileWriteMode]='error' OR [OutputL2CuratedFileWriteMode]='errorifexists');


GO
PRINT N'Creating Check Constraint [ELT].[CC_L2TransformDefinition_OutputDWTableWriteMode]...';


GO
ALTER TABLE [ELT].[L2TransformDefinition] WITH NOCHECK
    ADD CONSTRAINT [CC_L2TransformDefinition_OutputDWTableWriteMode] CHECK ([OutputDWTableWriteMode]='append' OR [OutputDWTableWriteMode]='overwrite' OR [OutputDWTableWriteMode]='ignore' OR [OutputDWTableWriteMode]='error' OR [OutputDWTableWriteMode]='errorifexists');


GO
PRINT N'Creating Check Constraint [ELT].[CC_L1TransformInstance_OutputL1CuratedFileWriteMode]...';


GO
ALTER TABLE [ELT].[L1TransformInstance] WITH NOCHECK
    ADD CONSTRAINT [CC_L1TransformInstance_OutputL1CuratedFileWriteMode] CHECK ([OutputL1CuratedFileWriteMode] ='append' OR [OutputL1CuratedFileWriteMode] ='overwrite' OR [OutputL1CuratedFileWriteMode] ='ignore'  OR [OutputL1CuratedFileWriteMode] = 'error' OR [OutputL1CuratedFileWriteMode]='errorifexists');


GO
PRINT N'Creating Check Constraint [ELT].[CC_L1TransformInstance_OutputDWTableWriteMode]...';


GO
ALTER TABLE [ELT].[L1TransformInstance] WITH NOCHECK
    ADD CONSTRAINT [CC_L1TransformInstance_OutputDWTableWriteMode] CHECK ([OutputDWTableWriteMode]='append' OR [OutputDWTableWriteMode]='overwrite' OR [OutputDWTableWriteMode]='error' OR [OutputDWTableWriteMode]='errorifexists' OR [OutputDWTableWriteMode]='ignore');


GO
PRINT N'Creating Check Constraint [ELT].[CC_L1TransformInstance_L1TransformStatus]...';


GO
ALTER TABLE [ELT].[L1TransformInstance] WITH NOCHECK
    ADD CONSTRAINT [CC_L1TransformInstance_L1TransformStatus] CHECK ([L1TransformStatus] ='ReRunFailure' OR [L1TransformStatus] ='ReRunSuccess' OR [L1TransformStatus] ='Running' OR [L1TransformStatus] ='DWUpload' OR [L1TransformStatus]='Failure' OR [L1TransformStatus]='Success');


GO
PRINT N'Creating Check Constraint [ELT].[CC_L1TransformDefinition_OutputL1CuratedFileWriteMode]...';


GO
ALTER TABLE [ELT].[L1TransformDefinition] WITH NOCHECK
    ADD CONSTRAINT [CC_L1TransformDefinition_OutputL1CuratedFileWriteMode] CHECK ([OutputL1CuratedFileWriteMode] ='append' OR [OutputL1CuratedFileWriteMode] ='overwrite' OR [OutputL1CuratedFileWriteMode] ='ignore'  OR [OutputL1CuratedFileWriteMode] = 'error' OR [OutputL1CuratedFileWriteMode]='errorifexists');


GO
PRINT N'Creating Check Constraint [ELT].[CC_L1TransformDefinition_OutputDWTableWriteMode]...';


GO
ALTER TABLE [ELT].[L1TransformDefinition] WITH NOCHECK
    ADD CONSTRAINT [CC_L1TransformDefinition_OutputDWTableWriteMode] CHECK ([OutputDWTableWriteMode]='append' OR [OutputDWTableWriteMode]='overwrite' OR [OutputDWTableWriteMode]='error' OR [OutputDWTableWriteMode]='errorifexists' OR [OutputDWTableWriteMode]='ignore');


GO
PRINT N'Creating Check Constraint [ELT].[CC_L1TransformDefinition_CustomParameters]...';


GO
ALTER TABLE [ELT].[L1TransformDefinition] WITH NOCHECK
    ADD CONSTRAINT [CC_L1TransformDefinition_CustomParameters] CHECK (ISJSON([CustomParameters]) = 1);


GO
PRINT N'Creating Check Constraint [ELT].[CC_IngestInstance_IngestStatus]...';


GO
ALTER TABLE [ELT].[IngestInstance] WITH NOCHECK
    ADD CONSTRAINT [CC_IngestInstance_IngestStatus] CHECK ([IngestStatus]='ReRunFailure' OR [IngestStatus]='ReRunSuccess' OR [IngestStatus]='Running' OR [IngestStatus]='Failure' OR [IngestStatus]='Success');


GO
PRINT N'Creating Check Constraint [ELT].[CC_IngestDefinition_SourceStructure]...';


GO
ALTER TABLE [ELT].[IngestDefinition] WITH NOCHECK
    ADD CONSTRAINT [CC_IngestDefinition_SourceStructure] CHECK (ISJSON([SourceStructure]) = 1);


GO
PRINT N'Creating Check Constraint [ELT].[CC_IngestDefinition_MaxIntervalNumber]...';


GO
ALTER TABLE [ELT].[IngestDefinition] WITH NOCHECK
    ADD CONSTRAINT [CC_IngestDefinition_MaxIntervalNumber] CHECK ([MaxIntervalNumber] IS NULL OR  [MaxIntervalNumber] > 0);


GO
PRINT N'Creating Check Constraint [ELT].[CC_IngestDefinition_MaxIntervalMinutes]...';


GO
ALTER TABLE [ELT].[IngestDefinition] WITH NOCHECK
    ADD CONSTRAINT [CC_IngestDefinition_MaxIntervalMinutes] CHECK ([MaxIntervalMinutes] IS NULL OR  [MaxIntervalMinutes] > 0);


GO
PRINT N'Creating Check Constraint [ELT].[CC_IngestDefinition_DataMapping]...';


GO
ALTER TABLE [ELT].[IngestDefinition] WITH NOCHECK
    ADD CONSTRAINT [CC_IngestDefinition_DataMapping] CHECK (ISJSON([DataMapping]) = 1);


GO
PRINT N'Creating Function [ELT].[uf_GetTabularTranslatorMappingJson]...';


GO
CREATE FUNCTION [ELT].[uf_GetTabularTranslatorMappingJson]
(
	@DataMappingJson VARCHAR(MAX)
)
RETURNS VARCHAR(MAX)
AS
BEGIN
	-- Uses standard ADF Explicit Schema Mapping
	-- https://docs.microsoft.com/en-us/azure/data-factory/copy-activity-schema-and-type-mapping
	DECLARE @TabularTranslatorJson VARCHAR(MAX) = '{
		"type": "TabularTranslator",
		"mappings": <MAPPINGS>
	}'
	RETURN REPLACE(@TabularTranslatorJson, '<MAPPINGS>', @DataMappingJson)
END
GO
PRINT N'Creating Function [ELT].[uf_GetAestDateTime]...';


GO
CREATE FUNCTION ELT.[uf_GetAestDateTime]()
RETURNS DATETIME
WITH EXECUTE AS CALLER
AS
 BEGIN
    RETURN CONVERT(datetime,CONVERT(datetimeoffset, getdate()) AT TIME ZONE 'AUS Eastern Standard Time')
END
GO
PRINT N'Creating Procedure [ELT].[UpdateTransformInstance_L2]...';


GO
CREATE PROCEDURE [ELT].[UpdateTransformInstance_L2]
	@L2TransformInstanceId INT
   ,@L2TransformStatus VARCHAR(20)
   ,@L2TransformADFPipelineRunID UNIQUEIDENTIFIER
   ,@InputCount INT = NULL
   ,@L2TransformCount INT = NULL
   ,@DataFromTimestamp Datetime2 = null
   ,@DataToTimestamp Datetime2 = null
   ,@DataFromNumber int = null
   ,@DataToNumber int = null
   ,@MaxRetries int = null
AS
BEGIN

	DECLARE @localdate datetime	= CONVERT(datetime,CONVERT(datetimeoffset, getdate()) at time zone 'AUS Eastern Standard Time')

		Update 
			[ELT].[L2TransformInstance]
		SET 
			[L2TransformStartTimestamp] = CASE 
											WHEN @L2TransformStatus IN ('Running') 
												THEN @localdate 
											ELSE [L2TransformStartTimestamp] 
										END

			, [L2TransformEndTimestamp] = CASE 
												WHEN @L2TransformStatus IN ('Success','Failure','ReRunSuccess','ReRunFailure') 
													THEN @localdate 
												ELSE NULL 
											END
			, [DataFromTimestamp] = @DataFromTimestamp
			, [DataToTimestamp] = @DataToTimestamp	
			, [DataFromNumber] = @DataFromNumber
			, [DataToNumber] = @DataToNumber
			, [L2TransformStatus] = CASE 
										WHEN ([ReRunL2TransformFlag] = 1 OR [RetryCount] > 0) AND @L2TransformStatus = 'Success' 
											THEN 'ReRunSuccess'
										WHEN [ReRunL2TransformFlag] = 1 AND @L2TransformStatus = 'Failure' 
											THEN 'ReRunFailure'
									ELSE @L2TransformStatus 
								 END
			, [ActiveFlag] = CASE 
								WHEN @L2TransformStatus IN ('Success','ReRunSuccess') 
									THEN 0
								WHEN @L2TransformStatus = 'Failure' and ISNULL(RetryCount,0) +1 >= @MaxRetries
									THEN 0
								ELSE 1 
							END
			, [ReRunL2TransformFlag] = CASE 
											WHEN [ReRunL2TransformFlag] =1 AND @L2TransformStatus IN ('Success','ReRunSuccess') 
												THEN 0
											WHEN @L2TransformStatus in ('Failure', 'ReRunFailure') and ISNULL(RetryCount,0) +1 >= @MaxRetries
													THEN 0
											ELSE [ReRunL2TransformFlag] 
										END
			, [RetryCount] = CASE
								WHEN
									@L2TransformStatus in ('Success', 'ReRunSuccess')
										THEN 0
								WHEN	
									@L2TransformStatus in ('Failure', 'ReRunFailure')
										THEN ISNULL([RetryCount],0) + 1
								ELSE [RetryCount]
								END
							
			, [ModifiedBy] =suser_sname()
			, [ModifiedTimestamp]=@localdate
			, [L2TransformADFPipelineRunID] = @L2TransformADFPipelineRunID
			, [InputCount] = ISNULL(@InputCount,[InputCount])
			, [L2TransformCount] = ISNULL(@L2TransformCount,[L2TransformCount])
		WHERE 
			[L2TransformInstanceID] = @L2TransformInstanceId
END
GO
PRINT N'Creating Procedure [ELT].[UpdateTransformInstance_L1]...';


GO
CREATE PROCEDURE [ELT].[UpdateTransformInstance_L1]
	@L1TransformInstanceId INT
   , @L1TransformStatus VARCHAR(20)
   , @L1TransformADFPipelineRunID UNIQUEIDENTIFIER
   , @IngestCount INT = NULL
   , @L1TransformCount INT = NULL
   , @MaxRetries int = null
AS
BEGIN
	
	DECLARE @localdate datetime	= CONVERT(datetime,CONVERT(datetimeoffset, getdate()) at time zone 'AUS Eastern Standard Time')

		Update 
			[ELT].[L1TransformInstance]
		SET 
			[L1TransformStartTimestamp] = CASE 
											WHEN @L1TransformStatus IN ('Running') 
												THEN @localdate 
											ELSE [L1TransformStartTimestamp] 
										END

			, [L1TransformEndTimestamp] = CASE
												WHEN @L1TransformStatus IN ('Success','Failure','ReRunSuccess','ReRunFailure') 
													THEN @localdate 
												ELSE NULL 
											END
										
			, [L1TransformStatus] = CASE 
										WHEN ([ReRunL1TransformFlag] = 1 OR [RetryCount] >0) AND @L1TransformStatus='Success' 
											THEN 'ReRunSuccess'
										WHEN [ReRunL1TransformFlag] = 1 AND @L1TransformStatus='Failure' 
											THEN 'ReRunFailure'
									ELSE @L1TransformStatus 
								 END
			, [ActiveFlag] = CASE
								WHEN @L1TransformStatus IN ('Success','ReRunSuccess') 
									THEN 0
								WHEN @L1TransformStatus = 'Failure' and ISNULL(RetryCount,0) +1 >= @MaxRetries
									THEN 0
								ELSE 1 
							END
			, [ReRunL1TransformFlag] =	CASE 
											WHEN [ReRunL1TransformFlag] = 1 AND @L1TransformStatus IN ('Success','ReRunSuccess') 
												THEN 0
											WHEN @L1TransformStatus in ('Failure', 'ReRunFailure') and ISNULL(RetryCount,0) +1 >= @MaxRetries
													THEN 0
											ELSE [ReRunL1TransformFlag] 
										END
			, [RetryCount] = CASE
								WHEN
									@L1TransformStatus in ('Success', 'ReRunSuccess')
										THEN 0
								WHEN	
									@L1TransformStatus in ('Failure', 'ReRunFailure')
										THEN ISNULL([RetryCount],0) + 1
								Else [RetryCount]
								END
							
			, [ModifiedBy] =suser_sname()
			, [ModifiedTimestamp]=@localdate
			, [L1TransformADFPipelineRunID] = @L1TransformADFPipelineRunID
			, [IngestCount] = ISNULL(@IngestCount,[IngestCount])
			, [L1TransformCount] = ISNULL(@L1TransformCount,[L1TransformCount])
	WHERE 
		[L1TransformInstanceID] = @L1TransformInstanceId
END
GO
PRINT N'Creating Procedure [ELT].[UpdateTransformDefinition_L2]...';


GO
CREATE PROCEDURE [ELT].[UpdateTransformDefinition_L2]
	@L2TransformID INT,
	@LastDeltaDate Datetime2 =null,
	@LastDeltaNumber int =null
	as
BEGIN
	Update [ELT].[L2TransformDefinition]
	SET 
		[ModifiedBy] =suser_sname(),
		[ModifiedTimestamp]=GETDATE(),
		[LastDeltaDate] = COALESCE(@LastDeltaDate,[LastDeltaDate],ELT.uf_GetAestDateTime()),
		[LastDeltaNumber] = COALESCE(@LastDeltaNumber,[LastDeltaNumber])

	WHERE [L2TransformID] = @L2TransformID
END
GO
PRINT N'Creating Procedure [ELT].[UpdateIngestInstance]...';


GO
CREATE PROCEDURE [ELT].[UpdateIngestInstance]
	@ADFIngestPipelineRunID Uniqueidentifier,
	@IngestStatus varchar(20) =null,
	@DataFromTimestamp Datetime2 =null,
	@DataToTimestamp Datetime2 =null,
	@DataFromNumber int =null,
	@DataToNumber int =null,
	@SourceCount int=null,
	@IngestCount int=null,
	@ReloadFlag bit
AS
BEGIN

		DECLARE @localdate as datetime	= CONVERT(datetime,CONVERT(datetimeoffset, getdate()) at time zone 'AUS Eastern Standard Time')

	Update 
		[ELT].[IngestInstance]
	SET 
		[DataFromTimestamp] = @DataFromTimestamp
		,[DataToTimestamp]=@DataToTimestamp
		,[DataFromNumber] = @DataFromNumber
		,[DataToNumber]=@DataToNumber
		,[SourceCount] =@SourceCount
		,[IngestCount]=@IngestCount
		,[IngestEndTimestamp] =@localdate
		,[IngestStatus] =(CASE WHEN @ReloadFlag=1 AND @IngestStatus='Success' THEN 'ReRunSuccess'
							WHEN   @ReloadFlag=1 AND @IngestStatus='Failure' THEN 'ReRunFailure'
							ELSE @IngestStatus
						END)
		,[RetryCount] = (CASE WHEN @IngestStatus  IN ('Success','ReRunSuccess') THEN 0
							WHEN @IngestStatus IN ('Failure','ReRunFailure')  THEN ISNULL([RetryCount],0) +1
						END)
		,[ReloadFlag] =(CASE WHEN @ReloadFlag=1 AND @IngestStatus IN ('Success','ReRunSuccess') THEN 0
							WHEN @ReloadFlag=1 AND @IngestStatus IN ('Failure','ReRunFailure') THEN 1
							ELSE 0
						 END)
		,[ModifiedBy]=suser_sname()
		,[ModifiedTimestamp] = @localdate
	WHERE
		ADFIngestPipelineRunID =@ADFIngestPipelineRunID
END
GO
PRINT N'Creating Procedure [ELT].[UpdateIngestDefinition]...';


GO
CREATE PROCEDURE [ELT].[UpdateIngestDefinition]
	@IngestID INT,
	@LastDeltaDate Datetime2=null,
	@LastDeltaNumer int=null,
	@IngestStatus varchar(20),
	@ReloadFlag bit=0
AS
BEGIN

		DECLARE @localdate as datetime	= CONVERT(datetime,CONVERT(datetimeoffset, getdate()) at time zone 'AUS Eastern Standard Time')

		Update 
			[ELT].[IngestDefinition]
		SET 
			[LastDeltaDate] =
							CASE
								--When Successful and the DataToDate does not move forward since LastDeltaDate, Increase LastDeltaDate by the Interval
								WHEN @LastDeltaDate IS NOT NULL AND @ReloadFlag <> 1 AND @IngestStatus IN ('Success','ReRunSuccess') AND @LastDeltaDate = [LastDeltaDate] 
									and [MaxIntervalMinutes] is NOT NULL
									THEN 
										CASE 
											WHEN 
												DateAdd(minute,[MaxIntervalMinutes],@LastDeltaDate) > ELT.[uf_GetAestDateTime]()
													THEN CONVERT(VARCHAR(30),ELT.[uf_GetAestDateTime](),120)
											ELSE
												DateAdd(minute,[MaxIntervalMinutes],[LastDeltaDate])
										END
								--Re-run delta date is later than existing delta date
								WHEN @LastDeltaDate IS NOT NULL AND @IngestStatus IN ('Success','ReRunSuccess') AND datediff_big(ss,[LastDeltaDate],@LastDeltaDate) >= 0 
									THEN @LastDeltaDate
								--Re-run delta date is earlier than existing delta date
								WHEN @LastDeltaDate IS NOT NULL AND @IngestStatus IN ('Success','ReRunSuccess')  AND datediff_big(ss,@LastDeltaDate,[LastDeltaDate]) >=0 
									THEN [LastDeltaDate]
								ELSE [LastDeltaDate]
							END
			, [LastDeltaNumber] = 
							CASE
								WHEN @LastDeltaNumer IS NOT NULL AND @IngestStatus IN ('Success','ReRunSuccess') 
									THEN @LastDeltaNumer
								WHEN @LastDeltaNumer IS NOT NULL AND @IngestStatus IN ('Failure','ReRunFailure') 
									THEN [LastDeltaNumber]
								WHEN @LastDeltaNumer IS NULL AND @ReloadFlag <> 1 AND @IngestStatus IN ('Success','ReRunSuccess')  
									THEN ([LastDeltaNumber] + [MaxIntervalNumber])
								ELSE [LastDeltaNumber]
							END
			,[ModifiedBy] =suser_sname()
			, [ModifiedTimestamp]=@localdate
	WHERE [IngestID]=@IngestID
END
GO
PRINT N'Creating Procedure [ELT].[InsertTransformInstance_L2]...';


GO
CREATE PROCEDURE [ELT].[InsertTransformInstance_L2]
	--PK/FK
	@L2TransformID int = null,
	@IngestID int,
	@L1TransformID int,

	--Databricks Notebook
	@NotebookName varchar(100) = null,
	@NotebookPath varchar(200) = null,

	--Custom
	@CustomParameters varchar(max) = null,

	--Input File
	@InputFileSystem varchar(50) = null,
    @InputFileFolder varchar(200) = null,
    @InputFile varchar(200) = null,
    @InputFileDelimiter char(1) = null,
	@InputFileHeaderFlag bit = null,
	@InputDWTable varchar(200) = null,

	--Delta
	@DeltaName varchar(50) = null,
	@DataFromTimestamp Datetime2 =null,
	@DataToTimestamp Datetime2 =null,
	@DataFromNumber int =null,
	@DataToNumber int =null,
	@LastDeltaDate datetime = null,
	@LastDeltaNumber int = null,


	--Curated File 
	@OutputL2CurateFileSystem varchar(50),
    @OutputL2CuratedFolder varchar(200),
    @OutputL2CuratedFile varchar(200),
    @OutputL2CuratedFileDelimiter char(1) = null,
    @OutputL2CuratedFileFormat varchar(10) = null,
    @OutputL2CuratedFileWriteMode varchar(20) = null,

	--SQL
	@OutputDWStagingTable varchar(200) = null,
	@LookupColumns varchar(4000) = null,	
    @OutputDWTable varchar(200) = null,
    @OutputDWTableWriteMode varchar(20) = null,
	

	--ADF Pipeline IDs
	@IngestADFPipelineRunID uniqueidentifier = null,
	@L1TransformADFPipelineRunID  uniqueidentifier = null,

	--Max Retries
	@MaxRetries int = null

AS
BEGIN

DECLARE @localdate as datetime	= CONVERT(datetime,CONVERT(datetimeoffset, getdate()) at time zone 'AUS Eastern Standard Time')

	--Check if Transformation records already exists for the input file for same transformation e.g it's a reload
		IF NOT EXISTS 
			(
				SELECT 1 
				FROM 
					[ELT].[L2TransformInstance]
				WHERE 
					[IngestID] = @IngestID
					AND L2TransformID = @L2TransformID
					--Check does curated file record already exist
					AND OutputL2CurateFileSystem = @OutputL2CurateFileSystem
					AND OutputL2CuratedFolder = @OutputL2CuratedFolder
					AND OutputL2CuratedFile = @OutputL2CuratedFile

			)


	BEGIN
	--If this is a new transformation
		INSERT INTO [ELT].[L2TransformInstance]
			(
				 [L2TransformID]
				,[IngestID]
				,[L1TransformID]
				,[NotebookPath]
				,[NotebookName]
				,[CustomParameters]
				,[InputFileSystem]
				,[InputFileFolder]
				,[InputFile]
				,[InputFileDelimiter]
				,[InputFileHeaderFlag]
				,[InputDWTable]
				,[DeltaName]
				,[OutputL2CurateFileSystem]
				,[OutputL2CuratedFolder]
				,[OutputL2CuratedFile]
				,[OutputL2CuratedFileDelimiter]
				,[OutputL2CuratedFileFormat]
				,[OutputL2CuratedFileWriteMode]
				,[OutputDWStagingTable]
				,[LookupColumns]
				,[OutputDWTable]
				,[OutputDWTableWriteMode]
				,[RetryCount]
				,[ActiveFlag]
				,[IngestADFPipelineRunID]
				,[L1TransformADFPipelineRunID] --1555
				,[CreatedBy]
				,[CreatedTimestamp]

			   
			)
		VALUES
			(
				@L2TransformID,
				@IngestID,
				@L1TransformID,
				@NotebookPath,
				@NotebookName,
				@CustomParameters,
				@InputFileSystem,
				@InputFileFolder,
				@InputFile,
				@InputFileDelimiter,
				@InputFileHeaderFlag,
				@InputDWTable,
				@DeltaName,
				@OutputL2CurateFileSystem,
				@OutputL2CuratedFolder,
				@OutputL2CuratedFile,
				@OutputL2CuratedFileDelimiter,
				@OutputL2CuratedFileFormat,
				@OutputL2CuratedFileWriteMode,
				@OutputDWStagingTable,
				@LookupColumns,
				@OutputDWTable,
				@OutputDWTableWriteMode,
				0,
				1,
				@IngestADFPipelineRunID,
				@L1TransformADFPipelineRunID,	--1555
				SUSER_NAME(),
				@localdate
		)
		END
	ELSE
		--If this is an existing Transformation
		BEGIN
			--Just update one record in case if there are duplicates
			UPDATE TOP (1) [ELT].[L2TransformInstance]
		SET 
			[InputCount] = null
			,[L2TransformCount] = null
			,[L2TransformStartTimestamp] = null
			,[L2TransformEndTimestamp] = null
			,[L2TransformStatus] = null
			,[RetryCount] = 0
			,[ActiveFlag] = 1
			,[ReRunL2TransformFlag] = 1
			,[IngestADFPipelineRunID] = @IngestADFPipelineRunID
			,[L1TransformADFPipelineRunID] = null
			,[L2TransformADFPipelineRunID] = null
			,[ModifiedBy] = suser_sname()
			,[ModifiedTimestamp] = @localdate
		WHERE 
			[IngestID] = @IngestID
			AND L2TransformID = @L2TransformID
			--Check does curated file record already exist
			AND OutputL2CurateFileSystem = @OutputL2CurateFileSystem
			AND OutputL2CuratedFolder = @OutputL2CuratedFolder
			AND OutputL2CuratedFile = @OutputL2CuratedFile
			AND (ActiveFlag = 0 AND ISNULL(RetryCount,0)  >= @MaxRetries)
				
		END
END
GO
PRINT N'Creating Procedure [ELT].[InsertTransformInstance_L1]...';


GO
CREATE PROCEDURE [ELT].[InsertTransformInstance_L1]
	--PK/FK
	@L1TransformID int = null,
	@IngestInstanceID int=null,
	@IngestID int,

	--Databricks Notebook
	@NotebookName varchar(100) = null,
	@NotebookPath varchar(200) = null,
	
	--Custom
	@CustomParameters varchar(max) = null,

	--Input File
	@InputRawFileSystem varchar(50) = null,
    @InputRawFileFolder varchar(200) = null,
    @InputRawFile varchar(200) = null,
    @InputRawFileDelimiter char(1) = null,
	@InputFileHeaderFlag bit = null,
	
	--Curated File 
	@OutputL1CurateFileSystem varchar(50) = null,
    @OutputL1CuratedFolder varchar(200) = null,
    @OutputL1CuratedFile varchar(200) = null,
    @OutputL1CuratedFileDelimiter char(1) = null,
    @OutputL1CuratedFileFormat varchar(10) = null,
    @OutputL1CuratedFileWriteMode varchar(20) = null,
    
	--SQL
	@OutputDWStagingTable varchar(200) = null,
	@LookupColumns varchar(4000) = null,
    @OutputDWTable varchar(200) = null,
    @OutputDWTableWriteMode varchar(20) = null,
    @IngestCount int = null,

	--ADF Pipeline IDs
	@IngestADFPipelineRunID  uniqueidentifier = null




AS
BEGIN


DECLARE @localdate as datetime	= CONVERT(datetime,CONVERT(datetimeoffset, getdate()) at time zone 'AUS Eastern Standard Time')

	--Check if Transformation records already exists for the input file for same transformation e.g it's a reload
		IF NOT EXISTS 
			(
				SELECT 1 
				FROM 
					[ELT].[L1TransformInstance]
				WHERE 
					[IngestID] = @IngestID
					AND L1TransformID = @L1TransformID
					AND InputRawFileSystem = @InputRawFileSystem
					AND InputRawFileFolder = @InputRawFileFolder
					AND InputRawFile = @InputRawFile
	
			)


	BEGIN
	--If this is a new transformation
		INSERT INTO [ELT].[L1TransformInstance]
			(
				[L1TransformID]
				,[IngestInstanceID]
				,[IngestID]
				,[NotebookName]
				,[NotebookPath]
				,[CustomParameters]
				,[InputRawFileSystem]
				,[InputRawFileFolder]
				,[InputRawFile]
				,[InputRawFileDelimiter]
				,[InputFileHeaderFlag]
				,[OutputL1CurateFileSystem]
				,[OutputL1CuratedFolder]
				,[OutputL1CuratedFile]
				,[OutputL1CuratedFileDelimiter]
				,[OutputL1CuratedFileFormat]
				,[OutputL1CuratedFileWriteMode]
				,[OutputDWStagingTable]
				,[LookupColumns]
				,[OutputDWTable]
				,[OutputDWTableWriteMode]
				,[RetryCount]
				,[ActiveFlag]
				,[IngestCount]
				,[IngestADFPipelineRunID]
				,[CreatedBy]
				,[CreatedTimestamp]
			   
			)
		VALUES
			(
				@L1TransformID
				,@IngestInstanceID
				,@IngestID
				,@NotebookName
				,@NotebookPath
				,@CustomParameters
				,@InputRawFileSystem
				,@InputRawFileFolder
				,@InputRawFile
				,@InputRawFileDelimiter
				,@InputFileHeaderFlag
				,@OutputL1CurateFileSystem
				,@OutputL1CuratedFolder
				,@OutputL1CuratedFile
				,@OutputL1CuratedFileDelimiter
				,@OutputL1CuratedFileFormat
				,@OutputL1CuratedFileWriteMode
				,@OutputDWStagingTable
				,@LookupColumns
				,@OutputDWTable
				,@OutputDWTableWriteMode
				,0
				,1
				,@IngestCount
				,@IngestADFPipelineRunID
				,SUSER_SNAME()
				,@localdate
		)
		END
	ELSE
		--If this is an existing Transformation
		BEGIN
			--Just update one record in case if there are duplicates
			UPDATE TOP (1) [ELT].[L1TransformInstance]
			SET 
				
				[IngestCount] = null
				,[L1TransformCount] = null
				,L1TransformStartTimestamp = null
				,[L1TransformEndTimestamp] = null
				,[L1TransformStatus] = null
				,[RetryCount] = 0
				,[ActiveFlag] = 1
				,[ReRunL1TransformFlag] = 1
				,[IngestADFPipelineRunID] = @IngestADFPipelineRunID
				,[L1TransformADFPipelineRunID] = null
				,[ModifiedBy] = suser_sname()
				,[ModifiedTimestamp] = @localdate
				
		WHERE 
			[IngestID] = @IngestID
			AND L1TransformID = @L1TransformID
			AND InputRawFileSystem = @InputRawFileSystem
			AND InputRawFileFolder = @InputRawFileFolder
			AND InputRawFile = @InputRawFile
		END
END
GO
PRINT N'Creating Procedure [ELT].[InsertIngestInstance]...';


GO
CREATE PROCEDURE [ELT].[InsertIngestInstance]
	@IngestID INT 
	,@SourceFileDropFileSystem varchar(50)=null 
	,@SourceFileDropFolder varchar(200)=null
	,@SourceFileDropFile varchar(200)=null
	,@DestinationRawFileSystem varchar(50)=null 
	,@DestinationRawFolder varchar(200)=null
	,@DestinationRawFile varchar(200)=null
	,@ReloadFlag bit =0
	,@ADFPipelineRunID UniqueIdentifier=null
AS

BEGIN

DECLARE @localdate as datetime	= CONVERT(datetime,CONVERT(datetimeoffset, getdate()) at time zone 'AUS Eastern Standard Time')


	--NOTE:Potential enhancements for lookup.
	-- 1. Job to Purge the Instance Tables to Blob after 3 months
	-- 2. Use the AdfPipeline Instance Run ID for the lookup, though this needs to be the individual. Lookup Including Index on the lookup columns.
	-- 3. Create a Hash Column on DestinationFileSystem/Folder/File and use as the lookup. Including Index on the lookup columns.

	--Normal Run
	IF (@ReloadFlag=0 AND NOT EXISTS (
										SELECT 1 
										FROM [ELT].[IngestInstance] 
										WHERE [DestinationRawFileSystem] = @DestinationRawFileSystem
										AND [DestinationRawFolder] = @DestinationRawFolder
										AND [DestinationRawFile] = @DestinationRawFile
									)
		)
	BEGIN
		INSERT INTO [ELT].[IngestInstance]
				   ([IngestID]
				   ,[SourceFileDropFileSystem]
				   ,[SourceFileDropFolder]
				   ,[SourceFileDropFile]
				   ,[DestinationRawFileSystem]
				   ,[DestinationRawFolder]
				   ,[DestinationRawFile]
				   ,[IngestStartTimestamp]
				   ,[IngestEndTimestamp]
				   ,[IngestStatus]
				   ,[RetryCount]
				   ,[ReloadFlag]
				   ,[CreatedBy]
				   ,[CreatedTimestamp]
				   ,[ModifiedBy]
				   ,[ModifiedTimestamp]
				   ,ADFIngestPipelineRunID)
			 VALUES
				   (@IngestID
				   ,@SourceFileDropFileSystem
				   ,@SourceFileDropFolder
				   ,@SourceFileDropFile
				   ,@DestinationRawFileSystem
				   ,@DestinationRawFolder
				   ,@DestinationRawFile
				   ,@localdate
				   ,NULL
				   ,'Running'
				   ,0
                   ,0
				   ,suser_sname()
				   ,@localdate
				   ,NULL
				   ,NULL
				   ,@ADFPipelineRunID)
	END

	--Re-load
	IF (@ReloadFlag=1 
		OR EXISTS (SELECT 1 FROM [ELT].[IngestInstance] 
					WHERE [DestinationRawFileSystem] = @DestinationRawFileSystem
						AND [DestinationRawFolder] = @DestinationRawFolder
						AND [DestinationRawFile] = @DestinationRawFile)
		)
	BEGIN
		Update [ELT].[IngestInstance]
		SET [IngestStartTimestamp] = @localdate
			,[IngestEndTimestamp] = NULL
			,[SourceCount]=NULL
			,[IngestCount]=NULL
			,[IngestStatus]='Running'
			,[ModifiedBy]=suser_sname()
			,[ModifiedTimestamp] = @localdate
			,ADFIngestPipelineRunID = @ADFPipelineRunID
		--Unique Keys
		WHERE [DestinationRawFileSystem] = @DestinationRawFileSystem
		AND [DestinationRawFolder] = @DestinationRawFolder
		AND [DestinationRawFile] = @DestinationRawFile
	END
END
GO
PRINT N'Creating Procedure [ELT].[GetTransformInstance_L2]...';


GO
CREATE PROCEDURE [ELT].[GetTransformInstance_L2]
	@SourceSystemName varchar(20),
	@StreamName varchar(100) = '%',
	@MaxTransformInstance int = 10,
	@L2TransformInstanceId INT = NULL, --To fetch all transform instances set Parameter as NULL otherwise provide a specific instance id
	@DelayL2TransformationFlag INT=NULL, --Pass @DelayL2TransformationFlag=0 to fetch all instances that needs to be transformed in the current pipeline (usually the ingestion pipeline). Pass =1 to fetch @DelayL2TransformationFlagh all transformations that are scheduled for a later time.
	@InputType varchar(15)	= '%',
	@L2TransformID INT=0 --To Fetch all transformations for a specific stream pass 0 otherwise provide TransformId prersent in L2Transsformdefinition
AS
begin
	--Limit Number of Transform Instances to prevent queuing at DWH
		SELECT TOP 
			(@MaxTransformInstance) 
			L2TI.[L2TransformInstanceID]
			, L2TI.[L2TransformID]
			, L2TI.[IngestID]
			, L2TI.[L1TransformID]
			, L2TI.[NotebookPath]
			, L2TI.[NotebookName]
			, L2TI.[CustomParameters]
			, L2TD.[InputType]
			, L2TI.[InputFileSystem]
			, L2TI.[InputFileFolder]
			, L2TI.[InputFile]
			, L2TI.[InputFileDelimiter]
			, L2TI.[InputFileHeaderFlag]
			, L2TI.[InputDWTable]
			, L2TI.[DeltaName]
			, L2TI.[DataFromTimestamp]
			, L2TI.[DataToTimestamp]
			, L2TI.[DataFromNumber]
			, L2TI.[DataToNumber]
			, L2TI.[OutputL2CurateFileSystem]
			, L2TI.[OutputL2CuratedFolder]
			, L2TI.[OutputL2CuratedFile]
			, L2TI.[OutputL2CuratedFileDelimiter]
			, L2TI.[OutputL2CuratedFileFormat]
			, L2TI.[OutputL2CuratedFileWriteMode]
			, L2TI.[OutputDWStagingTable]
			, L2TI.[LookupColumns]
			, L2TI.[OutputDWTable]
			, L2TI.[OutputDWTableWriteMode]
			, L2TI.[ReRunL2TransformFlag]
			, L2TD.[MaxRetries]
	
		FROM 
			[ELT].[L2TransformInstance] as L2TI
				LEFT JOIN [ELT].[L2TransformDefinition] as L2TD
					ON L2TI.[L2TransformID] = L2TD.[L2TransformID]
				LEFT JOIN [ELT].[IngestDefinition] as ID
					ON id.[IngestID]= L2TD.[IngestID]			
			WHERE 
				ID.[SourceSystemName] =@SourceSystemName
				AND ID.[StreamName] like COALESCE(@StreamName,id.[StreamName])
				AND (ID.ActiveFlag = 1 AND L2TD.ActiveFlag = 1)
				AND (L2TI.[ActiveFlag]=1 OR L2TI.[ReRunL2TransformFlag]=1)
				AND L2TI.[L2TransformInstanceID] = COALESCE(@L2TransformInstanceId, L2TI.[L2TransformInstanceID])
				AND (L2TI.[L2TransformStatus] IS NULL OR L2TI.[L2TransformStatus] NOT IN ('Running','DWUpload'))  --Fetch new instances and ignore instances that are currently running
				AND ID.[DelayL2TransformationFlag] = COALESCE(@DelayL2TransformationFlag,ID.[DelayL2TransformationFlag])
				AND L2TD.[InputType] like COALESCE(@InputType,L2TD.[InputType])
				--AND ISNULL(L2TI.RetryCount,0) <= L2TD.MaxRetries
				AND  L2TI.[L2TransformID]= (CASE WHEN @L2TransformID=0 then  L2TI.[L2TransformID] ELSE  @L2TransformID END)
			ORDER BY L2TD.RunSequence ASC, L2TI.[L2TransformInstanceID] ASC
END
GO
PRINT N'Creating Procedure [ELT].[GetTransformInstance_L1]...';


GO
CREATE PROCEDURE [ELT].[GetTransformInstance_L1]
	@SourceSystemName varchar(20),
	@StreamName varchar(100) = '%',
	@MaxTransformInstance int = 10,
	@L1TransformInstanceId INT = NULL, --To fetch all transform instances set Parameter as NULL otherwise provide a specific instance id
	@DelayL1TransformationFlag INT=NULL --Pass @DelayL1TransformationFlag=0 to fetch all instances that needs to be transformed in the current pipeline (usually the ingestion pipeline). Pass @DelayL1TransformationFlag=1 to fetch all transformations that are scheduled for a later time.
AS
begin
	--Limit Number of Transform Instances to prevent queuing at DWH
		SELECT top (@MaxTransformInstance) 
			L1TI.[L1TransformInstanceID]
			, L1TI.[L1TransformID]
			, L1TI.[IngestID]	
			, L1TI.[NotebookName]
			, L1TI.[NotebookPath]
			, L1TI.[CustomParameters]
			, L1TI.[InputRawFileSystem]
			, L1TI.[InputRawFileFolder]
			, L1TI.[InputRawFile]
			, L1TI.[InputRawFileDelimiter]
			, L1TI.[InputFileHeaderFlag]
			, L1TI.[OutputL1CurateFileSystem]
			, L1TI.[OutputL1CuratedFolder]
			, L1TI.[OutputL1CuratedFile]
			, L1TI.[OutputL1CuratedFileDelimiter]
			, L1TI.[OutputL1CuratedFileFormat]
			, L1TI.[OutputL1CuratedFileWriteMode]
			, L1TI.[OutputDWStagingTable]
			, L1TI.[LookupColumns]
			, L1TI.[OutputDWTable]
			, L1TI.[OutputDWTableWriteMode]
			, L1TI.[ReRunL1TransformFlag]
			, L1TD.[MaxRetries]
			, L1TD.[DeltaName]
			
		FROM 
			[ELT].[L1TransformInstance] as L1TI
				LEFT JOIN [ELT].[L1TransformDefinition] as L1TD
					ON L1TI.[L1TransformID] = L1TD.[L1TransformID]
				LEFT JOIN [ELT].[IngestDefinition] as ID
					ON id.[IngestID]= L1TD.[IngestID]		
			WHERE 
				ID.[SourceSystemName] =@SourceSystemName
				AND ID.[StreamName] like COALESCE(@StreamName,id.[StreamName])
				AND (ID.ActiveFlag = 1 AND L1TD.ActiveFlag = 1)
				AND (L1TI.[ActiveFlag]=1 OR L1TI.[ReRunL1TransformFlag]=1)
				AND L1TI.[L1TransformInstanceID] = COALESCE(@L1TransformInstanceId, L1TI.[L1TransformInstanceID])
				AND (L1TI.[L1TransformStatus] IS NULL OR L1TI.[L1TransformStatus] NOT IN ('Running','DWUpload'))  --Fetch new instances and ignore instances that are currently running
				AND ID.[DelayL1TransformationFlag] = COALESCE(@DelayL1TransformationFlag,ID.[DelayL1TransformationFlag])
				AND ISNULL(L1TI.RetryCount,0) <= L1TD.MaxRetries
			ORDER BY L1TI.[L1TransformInstanceID] ASC
END
GO
PRINT N'Creating Procedure [ELT].[GetTransformDefinition_L2]...';


GO
CREATE PROCEDURE [ELT].[GetTransformDefinition_L2] 
		@IngestID int, 
		@DeltaDate datetime = null,
		@InputType varchar(15) = '%'
AS
	--declare @IngestID int
	DECLARE @localdate datetime	= CONVERT(datetime,CONVERT(datetimeoffset, getdate()) at time zone 'AUS Eastern Standard Time')

	--Should be using L2DeltaTransformDate, if null then LocalDate
		SELECT
			--PK/FK
			TD.[L2TransformID]
			, TD.[IngestID]
			, TD.[L1TransformID]

			--Databricks
			, TD.[NotebookName]
			, TD.[NotebookPath]

			--Custom
			, TD.[CustomParameters]

			--InputType
			,TD.[InputType]

			 --Raw
			,TD.[InputFileSystem]
			,TD.[InputFileFolder]
			,TD.[InputFile]
			,TD.[InputFileDelimiter]
			,TD.[InputFileHeaderFlag]
			,TD.[InputDWTable]

			--Deltas
			,TD.[DeltaName]
			,[DataFromTimestamp] = NULL
			,[DataToTimestamp] = NULL
			,[DataFromNumber] = NULL
			,[DataToNumber] = NULL
			,TD.[MaxIntervalMinutes]
			,TD.[MaxIntervalNumber]
			

			--Retry
			,TD.[MaxRetries]

			--Curated File
			--Need to test how this performs with a file drop and filedrop reload. Possibly use date drop file was dropped?
			,TD.[OutputL2CurateFileSystem]
		
			,[OutputL2CuratedFolder] = 
					REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(TD.[OutputL2CuratedFolder] COLLATE SQL_Latin1_General_CP1_CS_AS
					,'YYYY',CAST(Year(COALESCE(TD.[LastDeltaDate],@DeltaDate,@localdate)) as varchar(4)))
					,'MM',Right('0'+ CAST(Month(COALESCE(TD.[LastDeltaDate],@DeltaDate,@localdate)) AS varchar(2)),2))
					,'DD',Right('0'+Cast(Day(COALESCE(TD.[LastDeltaDate],@localdate)) as varchar(2)),2))
					,'HH',Right('0'+ CAST(DatePart(hh,COALESCE(TD.[LastDeltaDate],@DeltaDate,@localdate)) as varchar(2)),2))
					,'MI',Right('0'+ CAST(DatePart(mi,COALESCE(TD.[LastDeltaDate],@DeltaDate,@localdate)) as varchar(2)),2))
					,'SS',Right('0'+ CAST(DatePart(ss,COALESCE(TD.[LastDeltaDate],@DeltaDate,@localdate)) as varchar(2)),2))

			,[OutputL2CuratedFile] = 
					REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(TD.[OutputL2CuratedFile] COLLATE SQL_Latin1_General_CP1_CS_AS
					,'YYYY',CAST(Year(COALESCE(TD.[LastDeltaDate],@DeltaDate,@localdate)) as varchar(4)))
					,'MM',Right('0'+ CAST(Month(COALESCE(TD.[LastDeltaDate],@DeltaDate,@localdate)) AS varchar(2)),2))
					,'DD',Right('0'+Cast(Day(COALESCE(TD.[LastDeltaDate],@DeltaDate,@localdate)) as varchar(2)),2))
					,'HH',Right('0'+ CAST(DatePart(hh,COALESCE(TD.[LastDeltaDate],@DeltaDate,@localdate)) as varchar(2)),2))
					,'MI',Right('0'+ CAST(DatePart(mi,COALESCE(TD.[LastDeltaDate],@DeltaDate,@localdate)) as varchar(2)),2))
					,'SS',Right('0'+ CAST(DatePart(ss,COALESCE(TD.[LastDeltaDate],@DeltaDate,@localdate)) as varchar(2)),2))

			, TD.[OutputL2CuratedFileDelimiter]
			, TD.[OutputL2CuratedFileFormat]
			, TD.[OutputL2CuratedFileWriteMode]

			--SQL
			,TD.[OutputDWStagingTable]
			,TD.[LookupColumns]
			,TD.[OutputDWTable]
			,TD.[OutputDWTableWriteMode]
			

		FROM
			[ELT].[L2TransformDefinition] TD
				LEFT JOIN [ELT].[IngestDefinition] ID
					ON TD.[IngestID] = ID.[IngestID]
		WHERE 
			TD.[IngestID] = @IngestID and 
			TD.[ActiveFlag] = 1
			and ID.[ActiveFlag] = 1
			and ID.[L2TransformationReqdFlag] =1
			and TD.[InputType] like COALESCE(@InputType,TD.[InputType])
GO
PRINT N'Creating Procedure [ELT].[GetTransformDefinition_L1]...';


GO
CREATE PROCEDURE [ELT].[GetTransformDefinition_L1] 
		@IngestID int, 
		@DeltaDate datetime = null 			
AS
	--declare @IngestID int 
	DECLARE @localdate datetime	= CONVERT(datetime,CONVERT(datetimeoffset, getdate()) AT TIME ZONE 'AUS Eastern Standard Time')
	DECLARE @CuratedDate datetime
	SET @CuratedDate = COALESCE(@DeltaDate,@localdate)


		SELECT 
			--PK/FK
			TD.[L1TransformID]
			, TD.[IngestID]

			
			--Databricks
			, TD.[NotebookName]
			, TD.[NotebookPath]
			
			--Custom
			, TD.[CustomParameters]

			 --Raw
			 ,TD.[InputRawFileDelimiter]
			 ,TD.[InputFileHeaderFlag]
			
			--Curated File
			--Need to test how this performs with a file drop and filedrop reload.
			--Possibly use date drop file was dropped?
			,TD.[OutputL1CurateFileSystem]
			
			,[OutputL1CuratedFolder] = 
					REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(TD.[OutputL1CuratedFolder]  COLLATE SQL_Latin1_General_CP1_CS_AS
					,'YYYY',CAST(Year(@CuratedDate) as varchar(4)))
					,'MM',Right('0'+ CAST(Month(@CuratedDate) AS varchar(2)),2))
					,'DD',Right('0'+Cast(Day(@CuratedDate) as varchar(2)),2))
					,'HH',Right('0'+ CAST(DatePart(hh,@CuratedDate) as varchar(2)),2))
					,'MI',Right('0'+ CAST(DatePart(mi,@CuratedDate) as varchar(2)),2))
					,'SS',Right('0'+ CAST(DatePart(ss,@CuratedDate) as varchar(2)),2))

			,[OutputL1CuratedFile] = 
					REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(TD.[OutputL1CuratedFile] COLLATE SQL_Latin1_General_CP1_CS_AS
					,'YYYY',CAST(Year(@CuratedDate) as varchar(4)))
					,'MM',Right('0'+ CAST(Month(@CuratedDate) AS varchar(2)),2))
					,'DD',Right('0'+Cast(Day(@CuratedDate) as varchar(2)),2))
					,'HH',Right('0'+ CAST(DatePart(hh,@CuratedDate) as varchar(2)),2))
					,'MI',Right('0'+ CAST(DatePart(mi,@CuratedDate) as varchar(2)),2))
					,'SS',Right('0'+ CAST(DatePart(ss,@CuratedDate) as varchar(2)),2))

			, TD.[OutputL1CuratedFileDelimiter]
			, TD.[OutputL1CuratedFileFormat]
			, TD.[OutputL1CuratedFileWriteMode]

			--SQL
			, [LookupColumns]
			, TD.[OutputDWStagingTable]
			, TD.[OutputDWTable]
			, TD.[OutputDWTableWriteMode]

			--Max Retries
			, TD.[MaxRetries]
			

		FROM
			[ELT].[L1TransformDefinition] TD
				LEFT JOIN [ELT].[IngestDefinition] ID
					ON TD.[IngestID] = ID.[IngestID]
		WHERE 
			TD.[IngestID] = @IngestID and 
			TD.[ActiveFlag] = 1 
			and ID.[ActiveFlag] = 1 
			and ID.[L1TransformationReqdFlag] =1
GO
PRINT N'Creating Procedure [ELT].[GetRunningTransformInstances]...';


GO
CREATE PROCEDURE [ELT].[GetRunningTransformInstances]
	@timespanHrs int = 18 --Default Timespan 18hrs
AS
	--Get the count of transform instances (L1 and L2) still active and running in last @timespanHrs
	DECLARE @L1Count INT, @L2Count INT

	IF @timespanHrs IS NULL OR @timespanHrs<=0 
		SET @timespanHrs=24

	SELECT @L1Count = COUNT(1)
	FROM ELT.L1TransformInstance
	WHERE L1TransformStatus='Running' 
	AND DateDiff(hour,L1TransformStartTimestamp,getdate()) <= @timespanHrs

	SELECT @L2Count= COUNT(1)
	FROM ELT.L2TransformInstance
	WHERE L2TransformStatus='Running'
	AND DateDiff(hour,L2TransformStartTimestamp,getdate()) <= @timespanHrs

	SELECT (@L1Count + @L2Count) AS RunningCount

RETURN
GO
PRINT N'Creating Procedure [ELT].[GetIngestDefinition_FileDrop]...';


GO
CREATE PROCEDURE [ELT].[GetIngestDefinition_FileDrop]
	@SourceSystemName varchar(20),
	@StreamName VARCHAR(100),
	@SourceFolder VARCHAR(250), --where SourceFolder=Container/Folder
	@SourceFile VARCHAR(200)
AS
--/*
--Generic Stored Procedure to be used for File Drop Pipelines instead of the [ELT].[GetIngestDefinition] procedure which is relevant for database ingest pipelines
--*/
BEGIN
--For Testing


	DECLARE @IngestID INT
	SELECT @IngestID = [IngestID] FROM [ELT].[IngestDefinition] WHERE [SourceSystemName]=@SourceSystemName AND [StreamName]=@StreamName and [ActiveFlag]=1

	--If the Source File already exists (Reload)
	IF EXISTS ( SELECT 1 FROM [ELT].[IngestInstance] 
				WHERE (
						CASE 
							WHEN [SourceFileDropFileSystem] IS NULL 
								THEN [SourceFileDropFolder] --In most cases container will be null as it is part of folder name from event trigger
							WHEN [SourceFileDropFileSystem] IS NOT NULL AND LEN(RTRIM([SourceFileDropFolder])) =0 
								THEN [SourceFileDropFolder]
							ELSE [SourceFileDropFileSystem] +'/' + [SourceFileDropFolder]
					   END ) =@SourceFolder 
				AND [SourceFileDropFile]=@SourceFile)
		
BEGIN
		SELECT 
			top 1 
			II.[IngestID]
			, ID.[SourceSystemName]
			, ID.[StreamName]
			,ID.[Backend]
			,ID.[DataFormat]
			, II.[SourceFileDropFileSystem]
			, REPLACE(II.[SourceFileDropFolder],ID.[SourceFileDropFileSystem] +'/','') AS [SourceFileDropFolder] --Remove container name from folder path
			, II.[SourceFileDropFile]
			, ID.[SourceFileDelimiter]
			, ID.[SourceFileHeaderFlag]
			, II.[DestinationRawFileSystem]
			, II.[DestinationRawFolder]
			, II.[DestinationRawFile]
			,[ELT].[uf_GetTabularTranslatorMappingJson](ID.[DataMapping]) AS [DataMapping]
			, CAST(1 AS BIT) AS [ReloadFlag]
			, ID.[L1TransformationReqdFlag]
			, ID.[L2TransformationReqdFlag]
			, ID.[DelayL1TransformationFlag]
			, ID.[DelayL2TransformationFlag]
			, II.[ADFIngestPipelineRunID]
			FROM 
				[ELT].[IngestInstance] AS II
					INNER JOIN [ELT].[IngestDefinition] AS ID
						ON II.[IngestID] =ID.[IngestID]
							AND II.[IngestID]=@IngestID
							AND (
								CASE 
									WHEN II.[SourceFileDropFileSystem] IS NULL 
										THEN II.[SourceFileDropFolder] --In most cases container will be null as it is part of folder name from event trigger
									WHEN II.[SourceFileDropFolder] IS NOT NULL AND LEN(RTRIM(II.[SourceFileDropFileSystem])) =0 
										THEN II.[SourceFileDropFolder] 
									ELSE II.[SourceFileDropFileSystem] +'/' + II.[SourceFileDropFolder]
								END ) = @SourceFolder 
							AND II.[SourceFileDropFile]=@SourceFile
			ORDER BY [IngestInstanceID] DESC
		END
	ELSE
	--If this is a new file
		BEGIN

		DECLARE @localdate as datetime	= CONVERT(datetime,CONVERT(datetimeoffset, getdate()) at time zone 'AUS Eastern Standard Time')

		SELECT 
			[IngestID]
			, [SourceSystemName]
			, [StreamName]		
			,[Backend]
			,[DataFormat]
			, [SourceFileDropFileSystem]
			, REPLACE(@SourceFolder,[SourceFileDropFileSystem] +'/','')  AS [SourceFileDropFolder] --Remove container name from folder path
			, @SourceFile AS [SourceFileDropFile]
			, [SourceFileDelimiter]
			, [SourceFileHeaderFlag]
			, [DestinationRawFileSystem]
			, [DestinationRawFolder] = 
				REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE([DestinationRawFolder] COLLATE SQL_Latin1_General_CP1_CS_AS
				,'YYYY',CAST(Year(@localdate) as varchar(4)))
				,'MM',Right('0'+ CAST(Month(@localdate) AS varchar(2)),2))
				,'DD',Right('0'+Cast(Day(@localdate) as varchar(2)),2))
				,'HH',Right('0'+ CAST(DatePart(hh,@localdate) as varchar(2)),2))
				,'MI',Right('0'+ CAST(DatePart(mi,@localdate) as varchar(2)),2))
				,'SS',Right('0'+ CAST(DatePart(ss,@localdate) as varchar(2)),2))
			
			, [DestinationRawFile] = 
				REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE([DestinationRawFile] COLLATE SQL_Latin1_General_CP1_CS_AS
				,'YYYY',CAST(Year(@localdate) AS varchar(4)))
				,'MM',Right('0'+ CAST(Month(@localdate) AS varchar(2)),2))
				,'DD',Right('0'+Cast(Day(@localdate) as varchar(2)),2))
				,'HH',Right('0'+ CAST(DatePart(hh,@localdate) AS varchar(2)),2))
				,'MI',Right('0'+ CAST(DatePart(mi,@localdate) AS varchar(2)),2))
				,'SS',Right('0'+ CAST(DatePart(ss,@localdate) AS varchar(2)),2))
			,[ELT].[uf_GetTabularTranslatorMappingJson]([DataMapping]) AS [DataMapping]
			, CAST(0 AS BIT) AS [ReloadFlag]
			, [L1TransformationReqdFlag]
			, [L2TransformationReqdFlag]
			, [DelayL1TransformationFlag]
			, [DelayL2TransformationFlag]
			, NULL AS [ADFPipelineRunID]
			
			FROM 
				[ELT].[IngestDefinition]
			WHERE 
				[IngestID]=@IngestID
		END
END
GO
PRINT N'Creating Procedure [ELT].[GetIngestDefinition]...';


GO
CREATE PROCEDURE [ELT].[GetIngestDefinition]
	@SourceSystemName varchar(20),
	@StreamName VARCHAR(100) = '%', --Default =All Streams
	@MaxIngestInstance INT = 10
	
AS
BEGIN
	
		DECLARE @localdate as datetime	= CONVERT(datetime,CONVERT(datetimeoffset, getdate()) at time zone 'AUS Eastern Standard Time');

with 
	cte
as

(	--Normal Run
			SELECT 
				 [IngestID]
				,[SourceSystemName]
				,[StreamName]
				,[Backend]
				,[EntityName]
				,[DeltaName]
				
				--Delta Dates
				,[LastDeltaDate]
				,[DataFromTimestamp] = 
								CASE 
									WHEN ([EntityName] IS NOT NULL AND [LastDeltaDate] IS NOT NULL) THEN [LastDeltaDate]
									ELSE CAST('1900-01-01' AS DateTime)
								END
				,[DataToTimestamp] = 
							CASE 
								WHEN ([EntityName] IS NOT NULL AND [LastDeltaDate] IS NOT NULL AND [MaxIntervalMinutes] IS NOT NULL AND datediff_big(minute,[LastDeltaDate],@localdate) > [MaxIntervalMinutes]) THEN DateAdd(minute,[MaxIntervalMinutes],[LastDeltaDate])
								WHEN ([EntityName] IS NOT NULL AND [LastDeltaDate] IS NOT NULL AND [MaxIntervalMinutes] IS NOT NULL AND datediff_big(minute,[LastDeltaDate],@localdate) <= [MaxIntervalMinutes]) THEN CONVERT(VARCHAR(30),@localdate,120)
								ELSE CONVERT(VARCHAR(30),@localdate,120) 
							END

				--Delta Numbers
				,[LastDeltaNumber]
				,[DataFromNumber] = 
							CASE 
								WHEN ([EntityName] IS NOT NULL AND [LastDeltaNumber] IS NOT NULL) THEN [LastDeltaNumber]
					  END
				,[DataToNumber] = 
								CASE 
									WHEN ([EntityName] IS NOT NULL AND [LastDeltaNumber] IS NOT NULL) THEN ([LastDeltaNumber] + [MaxIntervalNumber])
					   END

				,[DataFormat]
				,[SourceStructure]
				,[MaxIntervalMinutes]
				,[MaxIntervalNumber]
				,[ELT].[uf_GetTabularTranslatorMappingJson]([DataMapping]) AS [DataMapping]
				,[RunSequence]
				,[ActiveFlag]
				,[L1TransformationReqdFlag]
				,[L2TransformationReqdFlag]
				,[DelayL1TransformationFlag]
				,[DelayL2TransformationFlag]
				,[DestinationRawFileSystem]
		
			--Derived Fields
				,[DestinationRawFolder] = 
					REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE([DestinationRawFolder] COLLATE SQL_Latin1_General_CP1_CS_AS
					,'YYYY',CAST(Year(COALESCE([LastDeltaDate],@localdate)) as varchar(4)))
					,'MM',Right('0'+ CAST(Month(COALESCE([LastDeltaDate],@localdate)) AS varchar(2)),2))
					,'DD',Right('0'+Cast(Day(COALESCE([LastDeltaDate],@localdate)) as varchar(2)),2))
					,'HH',Right('0'+ CAST(DatePart(hh,COALESCE([LastDeltaDate],@localdate)) as varchar(2)),2))
					,'MI',Right('0'+ CAST(DatePart(mi,COALESCE([LastDeltaDate],@localdate)) as varchar(2)),2))
					,'SS',Right('0'+ CAST(DatePart(ss,COALESCE([LastDeltaDate],@localdate)) as varchar(2)),2))
			
				,[DestinationRawFile] = 
					REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE([DestinationRawFile] COLLATE SQL_Latin1_General_CP1_CS_AS
					,'YYYY',CAST(Year(COALESCE([LastDeltaDate],@localdate)) AS varchar(4)))
					,'MM',Right('0'+ CAST(Month(COALESCE([LastDeltaDate],@localdate)) AS varchar(2)),2))
					,'DD',Right('0'+Cast(Day(COALESCE([LastDeltaDate],@localdate)) as varchar(2)),2))
					,'HH',Right('0'+ CAST(DatePart(hh,COALESCE([LastDeltaDate],@localdate)) AS varchar(2)),2))
					,'MI',Right('0'+ CAST(DatePart(mi,COALESCE([LastDeltaDate],@localdate)) AS varchar(2)),2))
					,'SS',Right('0'+ CAST(DatePart(ss,COALESCE([LastDeltaDate],@localdate)) AS varchar(2)),2))			


			--Query
				,SourceSQL = 
					CASE
					 --DEFAULT ANSI SQL for Delta Table
						WHEN [EntityName] IS NOT NULL AND [DeltaName] IS NOT NULL AND [LastDeltaDate] IS NOT NULL
							THEN 
								CASE 
									WHEN datediff_big(minute,[LastDeltaDate],@localdate) > [MaxIntervalMinutes]
										THEN 
											'SELECT * FROM ' + [EntityName] + ' WHERE ' 
											+ [DeltaName] + ' > ' + ''''+CONVERT(VARCHAR(30),[LastDeltaDate],121) +''''+ ' AND ' + [DeltaName] + '<=' +  ''''+ CONVERT(VARCHAR(30), DATEADD(minute,[MaxIntervalMinutes],[LastDeltaDate]),121) +''''
									ELSE 
										'SELECT * FROM ' + [EntityName] + ' WHERE ' 
										+ [DeltaName] + ' > ' + ''''+ CONVERT(VARCHAR(30),[LastDeltaDate],121) +''''+ ' AND ' + [DeltaName] + '<='  + ''''+ CONVERT(VARCHAR(30), @localdate,120) +''''
								END
					 --DEFAULT ANSI SQL for Full Table
						WHEN [EntityName] IS NOT NULL AND [DeltaName] IS NULL
							THEN 
								'SELECT * FROM ' + [EntityName]
					--Running Number
						WHEN [EntityName] IS NOT NULL AND [DeltaName] IS NOT NULL AND [LastDeltaNumber] IS NOT NULL
							THEN 'SELECT * FROM ' + [EntityName] + ' WHERE ' 
												+ [DeltaName] + ' > ' + ''''+CONVERT(VARCHAR,[LastDeltaNumber]) +'''' + [DeltaName] + ' <= ' + ''''+CONVERT(VARCHAR,([LastDeltaNumber] + [MaxIntervalNumber])) +''''
						ELSE NULL
					 END
			
			--Stats Query
				,StatSQL = 
					CASE 
						--DEFAULT ANSI SQL For Delta Table
						WHEN [EntityName] IS NOT NULL AND [DeltaName] IS NOT NULL AND [LastDeltaDate] IS NOT NULL
								THEN 
									CASE 
										WHEN datediff_big(minute,[LastDeltaDate],@localdate) > [MaxIntervalMinutes] 
											THEN 
												'SELECT MIN('+[DeltaName]+') AS DataFromTimestamp, MAX('+[DeltaName]+') AS DataToTimestamp, count(1) as SourceCount FROM ' + [EntityName] + ' WHERE ' 
												+ [DeltaName] + ' > ' + ''''+CONVERT(varchar(30),LastDeltaDate,121)+''''+ ' AND ' + [DeltaName] + ' <= ' + ''''+CONVERT(varchar(30), DATEADD(minute,[MaxIntervalMinutes],[LastDeltaDate]),121)+''''
										ELSE 
											'SELECT MIN('+[DeltaName]+') AS DataFromTimestamp, MAX('+[DeltaName]+') AS DataToTimestamp, count(1) as SourceCount FROM ' + [EntityName] + ' WHERE ' 
											+ [DeltaName] + ' > ' + ''''+CONVERT(varchar(30),[LastDeltaDate],121) +''''+ ' AND ' + [DeltaName] + ' <= ' + ''''+ CONVERT(varchar(30),(@localdate),120)+''''
										END
						--Common No Delta
							WHEN [EntityName] IS NOT NULL AND [DeltaName] IS NULL
								THEN 'SELECT ''1900-01-01 00:00:00'' AS DataFromTimestamp, '''+CONVERT(VARCHAR(30),ELT.uf_GetAestDateTime(),120)+''' AS DataToTimestamp,  COUNT(*) AS SourceCount FROM ' + [EntityName]
						--Running Number
							WHEN [EntityName] IS NOT NULL AND [DeltaName] IS NOT NULL AND [LastDeltaNumber] IS NOT NULL
									THEN 'SELECT MIN('+[DeltaName]+') AS DataFromTimestamp,' + ' MAX('+[DeltaName]+') AS DataToTimestamp,'+ 'COUNT(*) AS SourceCount FROM ' + [EntityName]
													+ [DeltaName] + ' > ' + ''''+CONVERT(VARCHAR,[LastDeltaNumber])+'''' + ' AND ' + [DeltaName] + ' <= ' + ''''+CONVERT(VARCHAR,([LastDeltaNumber] + [MaxIntervalNumber]))+''''
							ELSE NULL
					 END

				, CAST(0 AS BIT) AS [ReloadFlag]
				, NULL AS [ADFPipelineRunID]
			FROM 
				[ELT].[IngestDefinition]
			WHERE 
				[SourceSystemName]=@SourceSystemName
				AND [StreamName] LIKE COALESCE(@StreamName, [StreamName])
				AND [ActiveFlag]=1

--ReRun
UNION
		SELECT 
				[ID].[IngestID]
				,[SourceSystemName]
				,[StreamName]
				,[Backend]
				,[EntityName]
				,[DeltaName]
				,[LastDeltaDate]
				,II.[DataFromTimestamp]
				,II.[DataToTimestamp]
				,ID.[LastDeltaNumber]
				,II.[DataFromNumber]
				,II.[DataToNumber]
				,[DataFormat]
				,[SourceStructure]
				,ID.[MaxIntervalMinutes]
				,ID.[MaxIntervalNumber]
				,[ELT].[uf_GetTabularTranslatorMappingJson](ID.[DataMapping]) AS [DataMapping]
				,ID.[RunSequence]
				,[ActiveFlag]
				,[L1TransformationReqdFlag]
				,[L2TransformationReqdFlag]
				,[DelayL1TransformationFlag]
				,[DelayL2TransformationFlag]
				,II.[DestinationRawFileSystem]
				,II.[DestinationRawFolder]
				,II.[DestinationRawFile] 		
			
				--Derived Fields
				,SourceSQL = 
					CASE
						--DEFAULT ANSI SQL for Delta Table
						WHEN [EntityName] IS NOT NULL AND [DeltaName] IS NOT NULL AND [LastDeltaDate] IS NOT NULL 
							THEN 'SELECT * FROM ' + [EntityName] + ' WHERE ' 
									+ [DeltaName] + ' > ' + ''''+ CONVERT(varchar(30),II.[DataFromTimestamp],121)+''''+ ' AND ' + [DeltaName] + ' <= ' + ''''+ CONVERT(varchar(30),II.[DataToTimestamp],121)+''''
						--Common No Delta
						WHEN [EntityName] IS NOT NULL AND [DeltaName] IS NULL
							THEN 'SELECT * FROM ' + [EntityName]
						--Running Number
						WHEN [EntityName] IS NOT NULL AND [DeltaName] IS NOT NULL AND [LastDeltaNumber] IS NOT NULL
								THEN 'SELECT * FROM ' + [EntityName] + ' WHERE ' 
												+ [DeltaName] + ' > ' + ''''+CONVERT(VARCHAR,II.[DataFromNumber])+'''' + ' AND ' + [DeltaName] + ' <= ' + ''''+CONVERT(VARCHAR,II.[DataToNumber])+''''
						
						ELSE NULL
					END

				,StatSQL = 
					CASE 
					--DEFAULT ANSI SQL for Delta Table
						WHEN [EntityName] IS NOT NULL AND [DeltaName] IS NOT NULL AND [LastDeltaDate] IS NOT NULL THEN
									'SELECT MIN('+[DeltaName]+') AS DataFromTimestamp, MAX('+[DeltaName]+') AS DataToTimestamp, count(1) as SourceCount FROM ' 
									+ [EntityName] + ' WHERE ' + [DeltaName] + '>' + ''''+CONVERT(varchar(30),II.DataFromTimestamp,121)+''''+ ' AND ' + [DeltaName] + '<='+ ''''+CONVERT(varchar(30),II.[DataToTimestamp],121)+''''
					--Common No Delta
						WHEN [EntityName] IS NOT NULL AND [DeltaName] IS NULL AND [LastDeltaDate] IS NOT NULL 
							THEN 'SELECT MIN('+[DeltaName]+') AS DataFromTimestamp,' + ' MAX('+[DeltaName]+') AS DataToTimestamp,'+ 'COUNT(*) AS SourceCount FROM ' + [EntityName]
					--Common No Delta
						WHEN [EntityName] IS NOT NULL AND [DeltaName] IS NULL
							THEN 'SELECT SELECT ''1900-01-01 00:00:00'' AS DataFromTimestamp, '''+CONVERT(VARCHAR(30),ELT.uf_GetAestDateTime(),120)+''' AS DataToTimestamp, COUNT(*) AS SourceCount FROM ' + [EntityName]
					--Running Number
						WHEN [EntityName] IS NOT NULL AND [DeltaName] IS NOT NULL AND [LastDeltaNumber] IS NOT NULL
								THEN 'SELECT MIN('+[DeltaName]+') AS DataFromTimestamp,' + ' MAX('+[DeltaName]+') AS DataToTimestamp,'+ 'COUNT(*) AS SourceCount FROM ' + [EntityName]
												+ [DeltaName] + ' > ' + ''''+CONVERT(VARCHAR,II.[DataFromNumber]) +'''' + ' AND ' + [DeltaName] + ' <= ' + ''''+CONVERT(VARCHAR,II.[DataToNumber])+''''
						ELSE NULL 	
					END

				,II.[ReloadFlag]
				, II.[ADFIngestPipelineRunID]
			FROM 
				[ELT].[IngestDefinition] ID
					INNER JOIN [ELT].[IngestInstance] AS II
						ON II.[IngestID]= ID.[IngestID] 
						AND II.[ReloadFlag]=1
						AND (II.[IngestStatus] is NULL OR II.[IngestStatus] != 'Running')  --Fetch new instances and ignore instances that are currently running
			WHERE 
				ID.[SourceSystemName]=@SourceSystemName
				AND ID.[StreamName] LIKE COALESCE(@StreamName, [StreamName])
				AND ID.[ActiveFlag]=1 
				AND ISNULL(II.RetryCount,0) <= ID.MaxRetries
				
	)
	SELECT 
		TOP (@MaxIngestInstance) *  
	FROM CTE
	ORDER BY 
		[RunSequence] ASC, [DataFromTimestamp] DESC, [DataToTimestamp] DESC

END
GO
/*
Post-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be appended to the build script.		
 Use SQLCMD syntax to include a file in the post-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the post-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/

--:r .\Script1.PostDeployment.sql
GO

GO
PRINT N'Checking existing data against newly created constraints';


GO
USE [$(DatabaseName)];


GO
ALTER TABLE [ELT].[L2TransformInstance] WITH CHECK CHECK CONSTRAINT [FK_L2TransformInstance_L2TransformID];

ALTER TABLE [ELT].[L2TransformInstance] WITH CHECK CHECK CONSTRAINT [FK_L2TransformInstance_L1TransformID];

ALTER TABLE [ELT].[L2TransformInstance] WITH CHECK CHECK CONSTRAINT [FK_L2TransformInstance_IngestID];

ALTER TABLE [ELT].[L2TransformDefinition] WITH CHECK CHECK CONSTRAINT [FK_L2TransformDefinition_IngestID];

ALTER TABLE [ELT].[L1TransformInstance] WITH CHECK CHECK CONSTRAINT [FK_L1TransformInstance_L1TransformID];

ALTER TABLE [ELT].[L1TransformInstance] WITH CHECK CHECK CONSTRAINT [FK_L1TransformInstance_IngestID];

ALTER TABLE [ELT].[L1TransformDefinition] WITH CHECK CHECK CONSTRAINT [FK_L1TransformDefinition_IngestID];

ALTER TABLE [ELT].[IngestInstance] WITH CHECK CHECK CONSTRAINT [FK_IngestInstance_IngestID];

ALTER TABLE [ELT].[L2TransformInstance] WITH CHECK CHECK CONSTRAINT [CC_L2TransformInstance_OutputL2CuratedFileWriteMode];

ALTER TABLE [ELT].[L2TransformInstance] WITH CHECK CHECK CONSTRAINT [CC_L2TransformInstance_OutputDWTableWriteMode];

ALTER TABLE [ELT].[L2TransformInstance] WITH CHECK CHECK CONSTRAINT [CC_L2TransformInstance_L2TransformStatus];

ALTER TABLE [ELT].[L2TransformDefinition] WITH CHECK CHECK CONSTRAINT [CC_L2TransformDefinition_MaxIntervalNumber];

ALTER TABLE [ELT].[L2TransformDefinition] WITH CHECK CHECK CONSTRAINT [CC_L2TransformDefinition_MaxIntervalMinutes];

ALTER TABLE [ELT].[L2TransformDefinition] WITH CHECK CHECK CONSTRAINT [CC_L2TransformDefinition_InputType];

ALTER TABLE [ELT].[L2TransformDefinition] WITH CHECK CHECK CONSTRAINT [CC_L2TransformDefinition_CustomParameters];

ALTER TABLE [ELT].[L2TransformDefinition] WITH CHECK CHECK CONSTRAINT [CC_L2TransformDefinition_OutputL2CuratedFileWriteMode];

ALTER TABLE [ELT].[L2TransformDefinition] WITH CHECK CHECK CONSTRAINT [CC_L2TransformDefinition_OutputDWTableWriteMode];

ALTER TABLE [ELT].[L1TransformInstance] WITH CHECK CHECK CONSTRAINT [CC_L1TransformInstance_OutputL1CuratedFileWriteMode];

ALTER TABLE [ELT].[L1TransformInstance] WITH CHECK CHECK CONSTRAINT [CC_L1TransformInstance_OutputDWTableWriteMode];

ALTER TABLE [ELT].[L1TransformInstance] WITH CHECK CHECK CONSTRAINT [CC_L1TransformInstance_L1TransformStatus];

ALTER TABLE [ELT].[L1TransformDefinition] WITH CHECK CHECK CONSTRAINT [CC_L1TransformDefinition_OutputL1CuratedFileWriteMode];

ALTER TABLE [ELT].[L1TransformDefinition] WITH CHECK CHECK CONSTRAINT [CC_L1TransformDefinition_OutputDWTableWriteMode];

ALTER TABLE [ELT].[L1TransformDefinition] WITH CHECK CHECK CONSTRAINT [CC_L1TransformDefinition_CustomParameters];

ALTER TABLE [ELT].[IngestInstance] WITH CHECK CHECK CONSTRAINT [CC_IngestInstance_IngestStatus];

ALTER TABLE [ELT].[IngestDefinition] WITH CHECK CHECK CONSTRAINT [CC_IngestDefinition_SourceStructure];

ALTER TABLE [ELT].[IngestDefinition] WITH CHECK CHECK CONSTRAINT [CC_IngestDefinition_MaxIntervalNumber];

ALTER TABLE [ELT].[IngestDefinition] WITH CHECK CHECK CONSTRAINT [CC_IngestDefinition_MaxIntervalMinutes];

ALTER TABLE [ELT].[IngestDefinition] WITH CHECK CHECK CONSTRAINT [CC_IngestDefinition_DataMapping];


GO
PRINT N'Update complete.';


GO
